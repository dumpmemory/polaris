// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"polaris/ent/blacklist"
	"polaris/ent/downloadclients"
	"polaris/ent/episode"
	"polaris/ent/history"
	"polaris/ent/importlist"
	"polaris/ent/indexers"
	"polaris/ent/media"
	"polaris/ent/notificationclient"
	"polaris/ent/predicate"
	"polaris/ent/schema"
	"polaris/ent/settings"
	"polaris/ent/storage"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBlacklist          = "Blacklist"
	TypeDownloadClients    = "DownloadClients"
	TypeEpisode            = "Episode"
	TypeHistory            = "History"
	TypeImportList         = "ImportList"
	TypeIndexers           = "Indexers"
	TypeMedia              = "Media"
	TypeNotificationClient = "NotificationClient"
	TypeSettings           = "Settings"
	TypeStorage            = "Storage"
)

// BlacklistMutation represents an operation that mutates the Blacklist nodes in the graph.
type BlacklistMutation struct {
	config
	op            Op
	typ           string
	id            *int
	_type         *blacklist.Type
	value         *schema.BlacklistValue
	notes         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Blacklist, error)
	predicates    []predicate.Blacklist
}

var _ ent.Mutation = (*BlacklistMutation)(nil)

// blacklistOption allows management of the mutation configuration using functional options.
type blacklistOption func(*BlacklistMutation)

// newBlacklistMutation creates new mutation for the Blacklist entity.
func newBlacklistMutation(c config, op Op, opts ...blacklistOption) *BlacklistMutation {
	m := &BlacklistMutation{
		config:        c,
		op:            op,
		typ:           TypeBlacklist,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBlacklistID sets the ID field of the mutation.
func withBlacklistID(id int) blacklistOption {
	return func(m *BlacklistMutation) {
		var (
			err   error
			once  sync.Once
			value *Blacklist
		)
		m.oldValue = func(ctx context.Context) (*Blacklist, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Blacklist.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBlacklist sets the old Blacklist of the mutation.
func withBlacklist(node *Blacklist) blacklistOption {
	return func(m *BlacklistMutation) {
		m.oldValue = func(context.Context) (*Blacklist, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BlacklistMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BlacklistMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BlacklistMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BlacklistMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Blacklist.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetType sets the "type" field.
func (m *BlacklistMutation) SetType(b blacklist.Type) {
	m._type = &b
}

// GetType returns the value of the "type" field in the mutation.
func (m *BlacklistMutation) GetType() (r blacklist.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldType(ctx context.Context) (v blacklist.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *BlacklistMutation) ResetType() {
	m._type = nil
}

// SetValue sets the "value" field.
func (m *BlacklistMutation) SetValue(sv schema.BlacklistValue) {
	m.value = &sv
}

// Value returns the value of the "value" field in the mutation.
func (m *BlacklistMutation) Value() (r schema.BlacklistValue, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldValue(ctx context.Context) (v schema.BlacklistValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *BlacklistMutation) ResetValue() {
	m.value = nil
}

// SetNotes sets the "notes" field.
func (m *BlacklistMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *BlacklistMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the Blacklist entity.
// If the Blacklist object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BlacklistMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *BlacklistMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[blacklist.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *BlacklistMutation) NotesCleared() bool {
	_, ok := m.clearedFields[blacklist.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *BlacklistMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, blacklist.FieldNotes)
}

// Where appends a list predicates to the BlacklistMutation builder.
func (m *BlacklistMutation) Where(ps ...predicate.Blacklist) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BlacklistMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BlacklistMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Blacklist, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BlacklistMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BlacklistMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Blacklist).
func (m *BlacklistMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BlacklistMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m._type != nil {
		fields = append(fields, blacklist.FieldType)
	}
	if m.value != nil {
		fields = append(fields, blacklist.FieldValue)
	}
	if m.notes != nil {
		fields = append(fields, blacklist.FieldNotes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BlacklistMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case blacklist.FieldType:
		return m.GetType()
	case blacklist.FieldValue:
		return m.Value()
	case blacklist.FieldNotes:
		return m.Notes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BlacklistMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case blacklist.FieldType:
		return m.OldType(ctx)
	case blacklist.FieldValue:
		return m.OldValue(ctx)
	case blacklist.FieldNotes:
		return m.OldNotes(ctx)
	}
	return nil, fmt.Errorf("unknown Blacklist field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistMutation) SetField(name string, value ent.Value) error {
	switch name {
	case blacklist.FieldType:
		v, ok := value.(blacklist.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case blacklist.FieldValue:
		v, ok := value.(schema.BlacklistValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case blacklist.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	}
	return fmt.Errorf("unknown Blacklist field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BlacklistMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BlacklistMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BlacklistMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Blacklist numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BlacklistMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(blacklist.FieldNotes) {
		fields = append(fields, blacklist.FieldNotes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BlacklistMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BlacklistMutation) ClearField(name string) error {
	switch name {
	case blacklist.FieldNotes:
		m.ClearNotes()
		return nil
	}
	return fmt.Errorf("unknown Blacklist nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BlacklistMutation) ResetField(name string) error {
	switch name {
	case blacklist.FieldType:
		m.ResetType()
		return nil
	case blacklist.FieldValue:
		m.ResetValue()
		return nil
	case blacklist.FieldNotes:
		m.ResetNotes()
		return nil
	}
	return fmt.Errorf("unknown Blacklist field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BlacklistMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BlacklistMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BlacklistMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BlacklistMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BlacklistMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BlacklistMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BlacklistMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Blacklist unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BlacklistMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Blacklist edge %s", name)
}

// DownloadClientsMutation represents an operation that mutates the DownloadClients nodes in the graph.
type DownloadClientsMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	enable                     *bool
	name                       *string
	implementation             *downloadclients.Implementation
	url                        *string
	user                       *string
	password                   *string
	settings                   *string
	priority1                  *int
	addpriority1               *int
	remove_completed_downloads *bool
	remove_failed_downloads    *bool
	tags                       *string
	clearedFields              map[string]struct{}
	done                       bool
	oldValue                   func(context.Context) (*DownloadClients, error)
	predicates                 []predicate.DownloadClients
}

var _ ent.Mutation = (*DownloadClientsMutation)(nil)

// downloadclientsOption allows management of the mutation configuration using functional options.
type downloadclientsOption func(*DownloadClientsMutation)

// newDownloadClientsMutation creates new mutation for the DownloadClients entity.
func newDownloadClientsMutation(c config, op Op, opts ...downloadclientsOption) *DownloadClientsMutation {
	m := &DownloadClientsMutation{
		config:        c,
		op:            op,
		typ:           TypeDownloadClients,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDownloadClientsID sets the ID field of the mutation.
func withDownloadClientsID(id int) downloadclientsOption {
	return func(m *DownloadClientsMutation) {
		var (
			err   error
			once  sync.Once
			value *DownloadClients
		)
		m.oldValue = func(ctx context.Context) (*DownloadClients, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DownloadClients.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDownloadClients sets the old DownloadClients of the mutation.
func withDownloadClients(node *DownloadClients) downloadclientsOption {
	return func(m *DownloadClientsMutation) {
		m.oldValue = func(context.Context) (*DownloadClients, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DownloadClientsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DownloadClientsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DownloadClientsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DownloadClientsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DownloadClients.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetEnable sets the "enable" field.
func (m *DownloadClientsMutation) SetEnable(b bool) {
	m.enable = &b
}

// Enable returns the value of the "enable" field in the mutation.
func (m *DownloadClientsMutation) Enable() (r bool, exists bool) {
	v := m.enable
	if v == nil {
		return
	}
	return *v, true
}

// OldEnable returns the old "enable" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldEnable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnable: %w", err)
	}
	return oldValue.Enable, nil
}

// ResetEnable resets all changes to the "enable" field.
func (m *DownloadClientsMutation) ResetEnable() {
	m.enable = nil
}

// SetName sets the "name" field.
func (m *DownloadClientsMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DownloadClientsMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DownloadClientsMutation) ResetName() {
	m.name = nil
}

// SetImplementation sets the "implementation" field.
func (m *DownloadClientsMutation) SetImplementation(d downloadclients.Implementation) {
	m.implementation = &d
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *DownloadClientsMutation) Implementation() (r downloadclients.Implementation, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldImplementation(ctx context.Context) (v downloadclients.Implementation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *DownloadClientsMutation) ResetImplementation() {
	m.implementation = nil
}

// SetURL sets the "url" field.
func (m *DownloadClientsMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *DownloadClientsMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *DownloadClientsMutation) ResetURL() {
	m.url = nil
}

// SetUser sets the "user" field.
func (m *DownloadClientsMutation) SetUser(s string) {
	m.user = &s
}

// User returns the value of the "user" field in the mutation.
func (m *DownloadClientsMutation) User() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUser returns the old "user" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldUser(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUser is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUser requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUser: %w", err)
	}
	return oldValue.User, nil
}

// ResetUser resets all changes to the "user" field.
func (m *DownloadClientsMutation) ResetUser() {
	m.user = nil
}

// SetPassword sets the "password" field.
func (m *DownloadClientsMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *DownloadClientsMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *DownloadClientsMutation) ResetPassword() {
	m.password = nil
}

// SetSettings sets the "settings" field.
func (m *DownloadClientsMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *DownloadClientsMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *DownloadClientsMutation) ResetSettings() {
	m.settings = nil
}

// SetPriority1 sets the "priority1" field.
func (m *DownloadClientsMutation) SetPriority1(i int) {
	m.priority1 = &i
	m.addpriority1 = nil
}

// Priority1 returns the value of the "priority1" field in the mutation.
func (m *DownloadClientsMutation) Priority1() (r int, exists bool) {
	v := m.priority1
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority1 returns the old "priority1" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldPriority1(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority1 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority1 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority1: %w", err)
	}
	return oldValue.Priority1, nil
}

// AddPriority1 adds i to the "priority1" field.
func (m *DownloadClientsMutation) AddPriority1(i int) {
	if m.addpriority1 != nil {
		*m.addpriority1 += i
	} else {
		m.addpriority1 = &i
	}
}

// AddedPriority1 returns the value that was added to the "priority1" field in this mutation.
func (m *DownloadClientsMutation) AddedPriority1() (r int, exists bool) {
	v := m.addpriority1
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority1 resets all changes to the "priority1" field.
func (m *DownloadClientsMutation) ResetPriority1() {
	m.priority1 = nil
	m.addpriority1 = nil
}

// SetRemoveCompletedDownloads sets the "remove_completed_downloads" field.
func (m *DownloadClientsMutation) SetRemoveCompletedDownloads(b bool) {
	m.remove_completed_downloads = &b
}

// RemoveCompletedDownloads returns the value of the "remove_completed_downloads" field in the mutation.
func (m *DownloadClientsMutation) RemoveCompletedDownloads() (r bool, exists bool) {
	v := m.remove_completed_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveCompletedDownloads returns the old "remove_completed_downloads" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldRemoveCompletedDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveCompletedDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveCompletedDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveCompletedDownloads: %w", err)
	}
	return oldValue.RemoveCompletedDownloads, nil
}

// ResetRemoveCompletedDownloads resets all changes to the "remove_completed_downloads" field.
func (m *DownloadClientsMutation) ResetRemoveCompletedDownloads() {
	m.remove_completed_downloads = nil
}

// SetRemoveFailedDownloads sets the "remove_failed_downloads" field.
func (m *DownloadClientsMutation) SetRemoveFailedDownloads(b bool) {
	m.remove_failed_downloads = &b
}

// RemoveFailedDownloads returns the value of the "remove_failed_downloads" field in the mutation.
func (m *DownloadClientsMutation) RemoveFailedDownloads() (r bool, exists bool) {
	v := m.remove_failed_downloads
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoveFailedDownloads returns the old "remove_failed_downloads" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldRemoveFailedDownloads(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoveFailedDownloads is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoveFailedDownloads requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoveFailedDownloads: %w", err)
	}
	return oldValue.RemoveFailedDownloads, nil
}

// ResetRemoveFailedDownloads resets all changes to the "remove_failed_downloads" field.
func (m *DownloadClientsMutation) ResetRemoveFailedDownloads() {
	m.remove_failed_downloads = nil
}

// SetTags sets the "tags" field.
func (m *DownloadClientsMutation) SetTags(s string) {
	m.tags = &s
}

// Tags returns the value of the "tags" field in the mutation.
func (m *DownloadClientsMutation) Tags() (r string, exists bool) {
	v := m.tags
	if v == nil {
		return
	}
	return *v, true
}

// OldTags returns the old "tags" field's value of the DownloadClients entity.
// If the DownloadClients object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DownloadClientsMutation) OldTags(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTags: %w", err)
	}
	return oldValue.Tags, nil
}

// ResetTags resets all changes to the "tags" field.
func (m *DownloadClientsMutation) ResetTags() {
	m.tags = nil
}

// Where appends a list predicates to the DownloadClientsMutation builder.
func (m *DownloadClientsMutation) Where(ps ...predicate.DownloadClients) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DownloadClientsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DownloadClientsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DownloadClients, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DownloadClientsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DownloadClientsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DownloadClients).
func (m *DownloadClientsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DownloadClientsMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.enable != nil {
		fields = append(fields, downloadclients.FieldEnable)
	}
	if m.name != nil {
		fields = append(fields, downloadclients.FieldName)
	}
	if m.implementation != nil {
		fields = append(fields, downloadclients.FieldImplementation)
	}
	if m.url != nil {
		fields = append(fields, downloadclients.FieldURL)
	}
	if m.user != nil {
		fields = append(fields, downloadclients.FieldUser)
	}
	if m.password != nil {
		fields = append(fields, downloadclients.FieldPassword)
	}
	if m.settings != nil {
		fields = append(fields, downloadclients.FieldSettings)
	}
	if m.priority1 != nil {
		fields = append(fields, downloadclients.FieldPriority1)
	}
	if m.remove_completed_downloads != nil {
		fields = append(fields, downloadclients.FieldRemoveCompletedDownloads)
	}
	if m.remove_failed_downloads != nil {
		fields = append(fields, downloadclients.FieldRemoveFailedDownloads)
	}
	if m.tags != nil {
		fields = append(fields, downloadclients.FieldTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DownloadClientsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case downloadclients.FieldEnable:
		return m.Enable()
	case downloadclients.FieldName:
		return m.Name()
	case downloadclients.FieldImplementation:
		return m.Implementation()
	case downloadclients.FieldURL:
		return m.URL()
	case downloadclients.FieldUser:
		return m.User()
	case downloadclients.FieldPassword:
		return m.Password()
	case downloadclients.FieldSettings:
		return m.Settings()
	case downloadclients.FieldPriority1:
		return m.Priority1()
	case downloadclients.FieldRemoveCompletedDownloads:
		return m.RemoveCompletedDownloads()
	case downloadclients.FieldRemoveFailedDownloads:
		return m.RemoveFailedDownloads()
	case downloadclients.FieldTags:
		return m.Tags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DownloadClientsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case downloadclients.FieldEnable:
		return m.OldEnable(ctx)
	case downloadclients.FieldName:
		return m.OldName(ctx)
	case downloadclients.FieldImplementation:
		return m.OldImplementation(ctx)
	case downloadclients.FieldURL:
		return m.OldURL(ctx)
	case downloadclients.FieldUser:
		return m.OldUser(ctx)
	case downloadclients.FieldPassword:
		return m.OldPassword(ctx)
	case downloadclients.FieldSettings:
		return m.OldSettings(ctx)
	case downloadclients.FieldPriority1:
		return m.OldPriority1(ctx)
	case downloadclients.FieldRemoveCompletedDownloads:
		return m.OldRemoveCompletedDownloads(ctx)
	case downloadclients.FieldRemoveFailedDownloads:
		return m.OldRemoveFailedDownloads(ctx)
	case downloadclients.FieldTags:
		return m.OldTags(ctx)
	}
	return nil, fmt.Errorf("unknown DownloadClients field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case downloadclients.FieldEnable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnable(v)
		return nil
	case downloadclients.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case downloadclients.FieldImplementation:
		v, ok := value.(downloadclients.Implementation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case downloadclients.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case downloadclients.FieldUser:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUser(v)
		return nil
	case downloadclients.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case downloadclients.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case downloadclients.FieldPriority1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority1(v)
		return nil
	case downloadclients.FieldRemoveCompletedDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveCompletedDownloads(v)
		return nil
	case downloadclients.FieldRemoveFailedDownloads:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoveFailedDownloads(v)
		return nil
	case downloadclients.FieldTags:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTags(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadClients field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DownloadClientsMutation) AddedFields() []string {
	var fields []string
	if m.addpriority1 != nil {
		fields = append(fields, downloadclients.FieldPriority1)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DownloadClientsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case downloadclients.FieldPriority1:
		return m.AddedPriority1()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DownloadClientsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case downloadclients.FieldPriority1:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority1(v)
		return nil
	}
	return fmt.Errorf("unknown DownloadClients numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DownloadClientsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DownloadClientsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DownloadClientsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DownloadClients nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DownloadClientsMutation) ResetField(name string) error {
	switch name {
	case downloadclients.FieldEnable:
		m.ResetEnable()
		return nil
	case downloadclients.FieldName:
		m.ResetName()
		return nil
	case downloadclients.FieldImplementation:
		m.ResetImplementation()
		return nil
	case downloadclients.FieldURL:
		m.ResetURL()
		return nil
	case downloadclients.FieldUser:
		m.ResetUser()
		return nil
	case downloadclients.FieldPassword:
		m.ResetPassword()
		return nil
	case downloadclients.FieldSettings:
		m.ResetSettings()
		return nil
	case downloadclients.FieldPriority1:
		m.ResetPriority1()
		return nil
	case downloadclients.FieldRemoveCompletedDownloads:
		m.ResetRemoveCompletedDownloads()
		return nil
	case downloadclients.FieldRemoveFailedDownloads:
		m.ResetRemoveFailedDownloads()
		return nil
	case downloadclients.FieldTags:
		m.ResetTags()
		return nil
	}
	return fmt.Errorf("unknown DownloadClients field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DownloadClientsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DownloadClientsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DownloadClientsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DownloadClientsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DownloadClientsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DownloadClientsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DownloadClientsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown DownloadClients unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DownloadClientsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown DownloadClients edge %s", name)
}

// EpisodeMutation represents an operation that mutates the Episode nodes in the graph.
type EpisodeMutation struct {
	config
	op                Op
	typ               string
	id                *int
	season_number     *int
	addseason_number  *int
	episode_number    *int
	addepisode_number *int
	title             *string
	overview          *string
	air_date          *string
	status            *episode.Status
	monitored         *bool
	target_file       *string
	clearedFields     map[string]struct{}
	media             *int
	clearedmedia      bool
	done              bool
	oldValue          func(context.Context) (*Episode, error)
	predicates        []predicate.Episode
}

var _ ent.Mutation = (*EpisodeMutation)(nil)

// episodeOption allows management of the mutation configuration using functional options.
type episodeOption func(*EpisodeMutation)

// newEpisodeMutation creates new mutation for the Episode entity.
func newEpisodeMutation(c config, op Op, opts ...episodeOption) *EpisodeMutation {
	m := &EpisodeMutation{
		config:        c,
		op:            op,
		typ:           TypeEpisode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEpisodeID sets the ID field of the mutation.
func withEpisodeID(id int) episodeOption {
	return func(m *EpisodeMutation) {
		var (
			err   error
			once  sync.Once
			value *Episode
		)
		m.oldValue = func(ctx context.Context) (*Episode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Episode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEpisode sets the old Episode of the mutation.
func withEpisode(node *Episode) episodeOption {
	return func(m *EpisodeMutation) {
		m.oldValue = func(context.Context) (*Episode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EpisodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EpisodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EpisodeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EpisodeMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Episode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMediaID sets the "media_id" field.
func (m *EpisodeMutation) SetMediaID(i int) {
	m.media = &i
}

// MediaID returns the value of the "media_id" field in the mutation.
func (m *EpisodeMutation) MediaID() (r int, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaID returns the old "media_id" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldMediaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaID: %w", err)
	}
	return oldValue.MediaID, nil
}

// ClearMediaID clears the value of the "media_id" field.
func (m *EpisodeMutation) ClearMediaID() {
	m.media = nil
	m.clearedFields[episode.FieldMediaID] = struct{}{}
}

// MediaIDCleared returns if the "media_id" field was cleared in this mutation.
func (m *EpisodeMutation) MediaIDCleared() bool {
	_, ok := m.clearedFields[episode.FieldMediaID]
	return ok
}

// ResetMediaID resets all changes to the "media_id" field.
func (m *EpisodeMutation) ResetMediaID() {
	m.media = nil
	delete(m.clearedFields, episode.FieldMediaID)
}

// SetSeasonNumber sets the "season_number" field.
func (m *EpisodeMutation) SetSeasonNumber(i int) {
	m.season_number = &i
	m.addseason_number = nil
}

// SeasonNumber returns the value of the "season_number" field in the mutation.
func (m *EpisodeMutation) SeasonNumber() (r int, exists bool) {
	v := m.season_number
	if v == nil {
		return
	}
	return *v, true
}

// OldSeasonNumber returns the old "season_number" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldSeasonNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeasonNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeasonNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeasonNumber: %w", err)
	}
	return oldValue.SeasonNumber, nil
}

// AddSeasonNumber adds i to the "season_number" field.
func (m *EpisodeMutation) AddSeasonNumber(i int) {
	if m.addseason_number != nil {
		*m.addseason_number += i
	} else {
		m.addseason_number = &i
	}
}

// AddedSeasonNumber returns the value that was added to the "season_number" field in this mutation.
func (m *EpisodeMutation) AddedSeasonNumber() (r int, exists bool) {
	v := m.addseason_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetSeasonNumber resets all changes to the "season_number" field.
func (m *EpisodeMutation) ResetSeasonNumber() {
	m.season_number = nil
	m.addseason_number = nil
}

// SetEpisodeNumber sets the "episode_number" field.
func (m *EpisodeMutation) SetEpisodeNumber(i int) {
	m.episode_number = &i
	m.addepisode_number = nil
}

// EpisodeNumber returns the value of the "episode_number" field in the mutation.
func (m *EpisodeMutation) EpisodeNumber() (r int, exists bool) {
	v := m.episode_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeNumber returns the old "episode_number" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldEpisodeNumber(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeNumber: %w", err)
	}
	return oldValue.EpisodeNumber, nil
}

// AddEpisodeNumber adds i to the "episode_number" field.
func (m *EpisodeMutation) AddEpisodeNumber(i int) {
	if m.addepisode_number != nil {
		*m.addepisode_number += i
	} else {
		m.addepisode_number = &i
	}
}

// AddedEpisodeNumber returns the value that was added to the "episode_number" field in this mutation.
func (m *EpisodeMutation) AddedEpisodeNumber() (r int, exists bool) {
	v := m.addepisode_number
	if v == nil {
		return
	}
	return *v, true
}

// ResetEpisodeNumber resets all changes to the "episode_number" field.
func (m *EpisodeMutation) ResetEpisodeNumber() {
	m.episode_number = nil
	m.addepisode_number = nil
}

// SetTitle sets the "title" field.
func (m *EpisodeMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *EpisodeMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *EpisodeMutation) ResetTitle() {
	m.title = nil
}

// SetOverview sets the "overview" field.
func (m *EpisodeMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *EpisodeMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ResetOverview resets all changes to the "overview" field.
func (m *EpisodeMutation) ResetOverview() {
	m.overview = nil
}

// SetAirDate sets the "air_date" field.
func (m *EpisodeMutation) SetAirDate(s string) {
	m.air_date = &s
}

// AirDate returns the value of the "air_date" field in the mutation.
func (m *EpisodeMutation) AirDate() (r string, exists bool) {
	v := m.air_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAirDate returns the old "air_date" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldAirDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirDate: %w", err)
	}
	return oldValue.AirDate, nil
}

// ResetAirDate resets all changes to the "air_date" field.
func (m *EpisodeMutation) ResetAirDate() {
	m.air_date = nil
}

// SetStatus sets the "status" field.
func (m *EpisodeMutation) SetStatus(e episode.Status) {
	m.status = &e
}

// Status returns the value of the "status" field in the mutation.
func (m *EpisodeMutation) Status() (r episode.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldStatus(ctx context.Context) (v episode.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *EpisodeMutation) ResetStatus() {
	m.status = nil
}

// SetMonitored sets the "monitored" field.
func (m *EpisodeMutation) SetMonitored(b bool) {
	m.monitored = &b
}

// Monitored returns the value of the "monitored" field in the mutation.
func (m *EpisodeMutation) Monitored() (r bool, exists bool) {
	v := m.monitored
	if v == nil {
		return
	}
	return *v, true
}

// OldMonitored returns the old "monitored" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldMonitored(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMonitored is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMonitored requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMonitored: %w", err)
	}
	return oldValue.Monitored, nil
}

// ResetMonitored resets all changes to the "monitored" field.
func (m *EpisodeMutation) ResetMonitored() {
	m.monitored = nil
}

// SetTargetFile sets the "target_file" field.
func (m *EpisodeMutation) SetTargetFile(s string) {
	m.target_file = &s
}

// TargetFile returns the value of the "target_file" field in the mutation.
func (m *EpisodeMutation) TargetFile() (r string, exists bool) {
	v := m.target_file
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetFile returns the old "target_file" field's value of the Episode entity.
// If the Episode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EpisodeMutation) OldTargetFile(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetFile is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetFile requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetFile: %w", err)
	}
	return oldValue.TargetFile, nil
}

// ClearTargetFile clears the value of the "target_file" field.
func (m *EpisodeMutation) ClearTargetFile() {
	m.target_file = nil
	m.clearedFields[episode.FieldTargetFile] = struct{}{}
}

// TargetFileCleared returns if the "target_file" field was cleared in this mutation.
func (m *EpisodeMutation) TargetFileCleared() bool {
	_, ok := m.clearedFields[episode.FieldTargetFile]
	return ok
}

// ResetTargetFile resets all changes to the "target_file" field.
func (m *EpisodeMutation) ResetTargetFile() {
	m.target_file = nil
	delete(m.clearedFields, episode.FieldTargetFile)
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *EpisodeMutation) ClearMedia() {
	m.clearedmedia = true
	m.clearedFields[episode.FieldMediaID] = struct{}{}
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *EpisodeMutation) MediaCleared() bool {
	return m.MediaIDCleared() || m.clearedmedia
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *EpisodeMutation) MediaIDs() (ids []int) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *EpisodeMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// Where appends a list predicates to the EpisodeMutation builder.
func (m *EpisodeMutation) Where(ps ...predicate.Episode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EpisodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EpisodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Episode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EpisodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EpisodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Episode).
func (m *EpisodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EpisodeMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.media != nil {
		fields = append(fields, episode.FieldMediaID)
	}
	if m.season_number != nil {
		fields = append(fields, episode.FieldSeasonNumber)
	}
	if m.episode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	if m.title != nil {
		fields = append(fields, episode.FieldTitle)
	}
	if m.overview != nil {
		fields = append(fields, episode.FieldOverview)
	}
	if m.air_date != nil {
		fields = append(fields, episode.FieldAirDate)
	}
	if m.status != nil {
		fields = append(fields, episode.FieldStatus)
	}
	if m.monitored != nil {
		fields = append(fields, episode.FieldMonitored)
	}
	if m.target_file != nil {
		fields = append(fields, episode.FieldTargetFile)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EpisodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldMediaID:
		return m.MediaID()
	case episode.FieldSeasonNumber:
		return m.SeasonNumber()
	case episode.FieldEpisodeNumber:
		return m.EpisodeNumber()
	case episode.FieldTitle:
		return m.Title()
	case episode.FieldOverview:
		return m.Overview()
	case episode.FieldAirDate:
		return m.AirDate()
	case episode.FieldStatus:
		return m.Status()
	case episode.FieldMonitored:
		return m.Monitored()
	case episode.FieldTargetFile:
		return m.TargetFile()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EpisodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case episode.FieldMediaID:
		return m.OldMediaID(ctx)
	case episode.FieldSeasonNumber:
		return m.OldSeasonNumber(ctx)
	case episode.FieldEpisodeNumber:
		return m.OldEpisodeNumber(ctx)
	case episode.FieldTitle:
		return m.OldTitle(ctx)
	case episode.FieldOverview:
		return m.OldOverview(ctx)
	case episode.FieldAirDate:
		return m.OldAirDate(ctx)
	case episode.FieldStatus:
		return m.OldStatus(ctx)
	case episode.FieldMonitored:
		return m.OldMonitored(ctx)
	case episode.FieldTargetFile:
		return m.OldTargetFile(ctx)
	}
	return nil, fmt.Errorf("unknown Episode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case episode.FieldMediaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaID(v)
		return nil
	case episode.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeasonNumber(v)
		return nil
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeNumber(v)
		return nil
	case episode.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case episode.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case episode.FieldAirDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirDate(v)
		return nil
	case episode.FieldStatus:
		v, ok := value.(episode.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case episode.FieldMonitored:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMonitored(v)
		return nil
	case episode.FieldTargetFile:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetFile(v)
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EpisodeMutation) AddedFields() []string {
	var fields []string
	if m.addseason_number != nil {
		fields = append(fields, episode.FieldSeasonNumber)
	}
	if m.addepisode_number != nil {
		fields = append(fields, episode.FieldEpisodeNumber)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EpisodeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case episode.FieldSeasonNumber:
		return m.AddedSeasonNumber()
	case episode.FieldEpisodeNumber:
		return m.AddedEpisodeNumber()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EpisodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case episode.FieldSeasonNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeasonNumber(v)
		return nil
	case episode.FieldEpisodeNumber:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Episode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EpisodeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(episode.FieldMediaID) {
		fields = append(fields, episode.FieldMediaID)
	}
	if m.FieldCleared(episode.FieldTargetFile) {
		fields = append(fields, episode.FieldTargetFile)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EpisodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EpisodeMutation) ClearField(name string) error {
	switch name {
	case episode.FieldMediaID:
		m.ClearMediaID()
		return nil
	case episode.FieldTargetFile:
		m.ClearTargetFile()
		return nil
	}
	return fmt.Errorf("unknown Episode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EpisodeMutation) ResetField(name string) error {
	switch name {
	case episode.FieldMediaID:
		m.ResetMediaID()
		return nil
	case episode.FieldSeasonNumber:
		m.ResetSeasonNumber()
		return nil
	case episode.FieldEpisodeNumber:
		m.ResetEpisodeNumber()
		return nil
	case episode.FieldTitle:
		m.ResetTitle()
		return nil
	case episode.FieldOverview:
		m.ResetOverview()
		return nil
	case episode.FieldAirDate:
		m.ResetAirDate()
		return nil
	case episode.FieldStatus:
		m.ResetStatus()
		return nil
	case episode.FieldMonitored:
		m.ResetMonitored()
		return nil
	case episode.FieldTargetFile:
		m.ResetTargetFile()
		return nil
	}
	return fmt.Errorf("unknown Episode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EpisodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.media != nil {
		edges = append(edges, episode.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EpisodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case episode.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EpisodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EpisodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EpisodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedia {
		edges = append(edges, episode.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EpisodeMutation) EdgeCleared(name string) bool {
	switch name {
	case episode.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EpisodeMutation) ClearEdge(name string) error {
	switch name {
	case episode.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown Episode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EpisodeMutation) ResetEdge(name string) error {
	switch name {
	case episode.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown Episode edge %s", name)
}

// HistoryMutation represents an operation that mutates the History nodes in the graph.
type HistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int
	media_id              *int
	addmedia_id           *int
	episode_id            *int
	addepisode_id         *int
	source_title          *string
	date                  *time.Time
	target_dir            *string
	size                  *int
	addsize               *int
	download_client_id    *int
	adddownload_client_id *int
	indexer_id            *int
	addindexer_id         *int
	link                  *string
	status                *history.Status
	saved                 *string
	clearedFields         map[string]struct{}
	done                  bool
	oldValue              func(context.Context) (*History, error)
	predicates            []predicate.History
}

var _ ent.Mutation = (*HistoryMutation)(nil)

// historyOption allows management of the mutation configuration using functional options.
type historyOption func(*HistoryMutation)

// newHistoryMutation creates new mutation for the History entity.
func newHistoryMutation(c config, op Op, opts ...historyOption) *HistoryMutation {
	m := &HistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistoryID sets the ID field of the mutation.
func withHistoryID(id int) historyOption {
	return func(m *HistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *History
		)
		m.oldValue = func(ctx context.Context) (*History, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().History.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistory sets the old History of the mutation.
func withHistory(node *History) historyOption {
	return func(m *HistoryMutation) {
		m.oldValue = func(context.Context) (*History, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HistoryMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HistoryMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().History.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetMediaID sets the "media_id" field.
func (m *HistoryMutation) SetMediaID(i int) {
	m.media_id = &i
	m.addmedia_id = nil
}

// MediaID returns the value of the "media_id" field in the mutation.
func (m *HistoryMutation) MediaID() (r int, exists bool) {
	v := m.media_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaID returns the old "media_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldMediaID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaID: %w", err)
	}
	return oldValue.MediaID, nil
}

// AddMediaID adds i to the "media_id" field.
func (m *HistoryMutation) AddMediaID(i int) {
	if m.addmedia_id != nil {
		*m.addmedia_id += i
	} else {
		m.addmedia_id = &i
	}
}

// AddedMediaID returns the value that was added to the "media_id" field in this mutation.
func (m *HistoryMutation) AddedMediaID() (r int, exists bool) {
	v := m.addmedia_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetMediaID resets all changes to the "media_id" field.
func (m *HistoryMutation) ResetMediaID() {
	m.media_id = nil
	m.addmedia_id = nil
}

// SetEpisodeID sets the "episode_id" field.
func (m *HistoryMutation) SetEpisodeID(i int) {
	m.episode_id = &i
	m.addepisode_id = nil
}

// EpisodeID returns the value of the "episode_id" field in the mutation.
func (m *HistoryMutation) EpisodeID() (r int, exists bool) {
	v := m.episode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEpisodeID returns the old "episode_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldEpisodeID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpisodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpisodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpisodeID: %w", err)
	}
	return oldValue.EpisodeID, nil
}

// AddEpisodeID adds i to the "episode_id" field.
func (m *HistoryMutation) AddEpisodeID(i int) {
	if m.addepisode_id != nil {
		*m.addepisode_id += i
	} else {
		m.addepisode_id = &i
	}
}

// AddedEpisodeID returns the value that was added to the "episode_id" field in this mutation.
func (m *HistoryMutation) AddedEpisodeID() (r int, exists bool) {
	v := m.addepisode_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearEpisodeID clears the value of the "episode_id" field.
func (m *HistoryMutation) ClearEpisodeID() {
	m.episode_id = nil
	m.addepisode_id = nil
	m.clearedFields[history.FieldEpisodeID] = struct{}{}
}

// EpisodeIDCleared returns if the "episode_id" field was cleared in this mutation.
func (m *HistoryMutation) EpisodeIDCleared() bool {
	_, ok := m.clearedFields[history.FieldEpisodeID]
	return ok
}

// ResetEpisodeID resets all changes to the "episode_id" field.
func (m *HistoryMutation) ResetEpisodeID() {
	m.episode_id = nil
	m.addepisode_id = nil
	delete(m.clearedFields, history.FieldEpisodeID)
}

// SetSourceTitle sets the "source_title" field.
func (m *HistoryMutation) SetSourceTitle(s string) {
	m.source_title = &s
}

// SourceTitle returns the value of the "source_title" field in the mutation.
func (m *HistoryMutation) SourceTitle() (r string, exists bool) {
	v := m.source_title
	if v == nil {
		return
	}
	return *v, true
}

// OldSourceTitle returns the old "source_title" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldSourceTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSourceTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSourceTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSourceTitle: %w", err)
	}
	return oldValue.SourceTitle, nil
}

// ResetSourceTitle resets all changes to the "source_title" field.
func (m *HistoryMutation) ResetSourceTitle() {
	m.source_title = nil
}

// SetDate sets the "date" field.
func (m *HistoryMutation) SetDate(t time.Time) {
	m.date = &t
}

// Date returns the value of the "date" field in the mutation.
func (m *HistoryMutation) Date() (r time.Time, exists bool) {
	v := m.date
	if v == nil {
		return
	}
	return *v, true
}

// OldDate returns the old "date" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDate: %w", err)
	}
	return oldValue.Date, nil
}

// ResetDate resets all changes to the "date" field.
func (m *HistoryMutation) ResetDate() {
	m.date = nil
}

// SetTargetDir sets the "target_dir" field.
func (m *HistoryMutation) SetTargetDir(s string) {
	m.target_dir = &s
}

// TargetDir returns the value of the "target_dir" field in the mutation.
func (m *HistoryMutation) TargetDir() (r string, exists bool) {
	v := m.target_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDir returns the old "target_dir" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldTargetDir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDir: %w", err)
	}
	return oldValue.TargetDir, nil
}

// ResetTargetDir resets all changes to the "target_dir" field.
func (m *HistoryMutation) ResetTargetDir() {
	m.target_dir = nil
}

// SetSize sets the "size" field.
func (m *HistoryMutation) SetSize(i int) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *HistoryMutation) Size() (r int, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldSize(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *HistoryMutation) AddSize(i int) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *HistoryMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ResetSize resets all changes to the "size" field.
func (m *HistoryMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
}

// SetDownloadClientID sets the "download_client_id" field.
func (m *HistoryMutation) SetDownloadClientID(i int) {
	m.download_client_id = &i
	m.adddownload_client_id = nil
}

// DownloadClientID returns the value of the "download_client_id" field in the mutation.
func (m *HistoryMutation) DownloadClientID() (r int, exists bool) {
	v := m.download_client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadClientID returns the old "download_client_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldDownloadClientID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadClientID: %w", err)
	}
	return oldValue.DownloadClientID, nil
}

// AddDownloadClientID adds i to the "download_client_id" field.
func (m *HistoryMutation) AddDownloadClientID(i int) {
	if m.adddownload_client_id != nil {
		*m.adddownload_client_id += i
	} else {
		m.adddownload_client_id = &i
	}
}

// AddedDownloadClientID returns the value that was added to the "download_client_id" field in this mutation.
func (m *HistoryMutation) AddedDownloadClientID() (r int, exists bool) {
	v := m.adddownload_client_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearDownloadClientID clears the value of the "download_client_id" field.
func (m *HistoryMutation) ClearDownloadClientID() {
	m.download_client_id = nil
	m.adddownload_client_id = nil
	m.clearedFields[history.FieldDownloadClientID] = struct{}{}
}

// DownloadClientIDCleared returns if the "download_client_id" field was cleared in this mutation.
func (m *HistoryMutation) DownloadClientIDCleared() bool {
	_, ok := m.clearedFields[history.FieldDownloadClientID]
	return ok
}

// ResetDownloadClientID resets all changes to the "download_client_id" field.
func (m *HistoryMutation) ResetDownloadClientID() {
	m.download_client_id = nil
	m.adddownload_client_id = nil
	delete(m.clearedFields, history.FieldDownloadClientID)
}

// SetIndexerID sets the "indexer_id" field.
func (m *HistoryMutation) SetIndexerID(i int) {
	m.indexer_id = &i
	m.addindexer_id = nil
}

// IndexerID returns the value of the "indexer_id" field in the mutation.
func (m *HistoryMutation) IndexerID() (r int, exists bool) {
	v := m.indexer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexerID returns the old "indexer_id" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldIndexerID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexerID: %w", err)
	}
	return oldValue.IndexerID, nil
}

// AddIndexerID adds i to the "indexer_id" field.
func (m *HistoryMutation) AddIndexerID(i int) {
	if m.addindexer_id != nil {
		*m.addindexer_id += i
	} else {
		m.addindexer_id = &i
	}
}

// AddedIndexerID returns the value that was added to the "indexer_id" field in this mutation.
func (m *HistoryMutation) AddedIndexerID() (r int, exists bool) {
	v := m.addindexer_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearIndexerID clears the value of the "indexer_id" field.
func (m *HistoryMutation) ClearIndexerID() {
	m.indexer_id = nil
	m.addindexer_id = nil
	m.clearedFields[history.FieldIndexerID] = struct{}{}
}

// IndexerIDCleared returns if the "indexer_id" field was cleared in this mutation.
func (m *HistoryMutation) IndexerIDCleared() bool {
	_, ok := m.clearedFields[history.FieldIndexerID]
	return ok
}

// ResetIndexerID resets all changes to the "indexer_id" field.
func (m *HistoryMutation) ResetIndexerID() {
	m.indexer_id = nil
	m.addindexer_id = nil
	delete(m.clearedFields, history.FieldIndexerID)
}

// SetLink sets the "link" field.
func (m *HistoryMutation) SetLink(s string) {
	m.link = &s
}

// Link returns the value of the "link" field in the mutation.
func (m *HistoryMutation) Link() (r string, exists bool) {
	v := m.link
	if v == nil {
		return
	}
	return *v, true
}

// OldLink returns the old "link" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLink: %w", err)
	}
	return oldValue.Link, nil
}

// ClearLink clears the value of the "link" field.
func (m *HistoryMutation) ClearLink() {
	m.link = nil
	m.clearedFields[history.FieldLink] = struct{}{}
}

// LinkCleared returns if the "link" field was cleared in this mutation.
func (m *HistoryMutation) LinkCleared() bool {
	_, ok := m.clearedFields[history.FieldLink]
	return ok
}

// ResetLink resets all changes to the "link" field.
func (m *HistoryMutation) ResetLink() {
	m.link = nil
	delete(m.clearedFields, history.FieldLink)
}

// SetStatus sets the "status" field.
func (m *HistoryMutation) SetStatus(h history.Status) {
	m.status = &h
}

// Status returns the value of the "status" field in the mutation.
func (m *HistoryMutation) Status() (r history.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldStatus(ctx context.Context) (v history.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *HistoryMutation) ResetStatus() {
	m.status = nil
}

// SetSaved sets the "saved" field.
func (m *HistoryMutation) SetSaved(s string) {
	m.saved = &s
}

// Saved returns the value of the "saved" field in the mutation.
func (m *HistoryMutation) Saved() (r string, exists bool) {
	v := m.saved
	if v == nil {
		return
	}
	return *v, true
}

// OldSaved returns the old "saved" field's value of the History entity.
// If the History object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HistoryMutation) OldSaved(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSaved is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSaved requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSaved: %w", err)
	}
	return oldValue.Saved, nil
}

// ClearSaved clears the value of the "saved" field.
func (m *HistoryMutation) ClearSaved() {
	m.saved = nil
	m.clearedFields[history.FieldSaved] = struct{}{}
}

// SavedCleared returns if the "saved" field was cleared in this mutation.
func (m *HistoryMutation) SavedCleared() bool {
	_, ok := m.clearedFields[history.FieldSaved]
	return ok
}

// ResetSaved resets all changes to the "saved" field.
func (m *HistoryMutation) ResetSaved() {
	m.saved = nil
	delete(m.clearedFields, history.FieldSaved)
}

// Where appends a list predicates to the HistoryMutation builder.
func (m *HistoryMutation) Where(ps ...predicate.History) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.History, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (History).
func (m *HistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HistoryMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.media_id != nil {
		fields = append(fields, history.FieldMediaID)
	}
	if m.episode_id != nil {
		fields = append(fields, history.FieldEpisodeID)
	}
	if m.source_title != nil {
		fields = append(fields, history.FieldSourceTitle)
	}
	if m.date != nil {
		fields = append(fields, history.FieldDate)
	}
	if m.target_dir != nil {
		fields = append(fields, history.FieldTargetDir)
	}
	if m.size != nil {
		fields = append(fields, history.FieldSize)
	}
	if m.download_client_id != nil {
		fields = append(fields, history.FieldDownloadClientID)
	}
	if m.indexer_id != nil {
		fields = append(fields, history.FieldIndexerID)
	}
	if m.link != nil {
		fields = append(fields, history.FieldLink)
	}
	if m.status != nil {
		fields = append(fields, history.FieldStatus)
	}
	if m.saved != nil {
		fields = append(fields, history.FieldSaved)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case history.FieldMediaID:
		return m.MediaID()
	case history.FieldEpisodeID:
		return m.EpisodeID()
	case history.FieldSourceTitle:
		return m.SourceTitle()
	case history.FieldDate:
		return m.Date()
	case history.FieldTargetDir:
		return m.TargetDir()
	case history.FieldSize:
		return m.Size()
	case history.FieldDownloadClientID:
		return m.DownloadClientID()
	case history.FieldIndexerID:
		return m.IndexerID()
	case history.FieldLink:
		return m.Link()
	case history.FieldStatus:
		return m.Status()
	case history.FieldSaved:
		return m.Saved()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case history.FieldMediaID:
		return m.OldMediaID(ctx)
	case history.FieldEpisodeID:
		return m.OldEpisodeID(ctx)
	case history.FieldSourceTitle:
		return m.OldSourceTitle(ctx)
	case history.FieldDate:
		return m.OldDate(ctx)
	case history.FieldTargetDir:
		return m.OldTargetDir(ctx)
	case history.FieldSize:
		return m.OldSize(ctx)
	case history.FieldDownloadClientID:
		return m.OldDownloadClientID(ctx)
	case history.FieldIndexerID:
		return m.OldIndexerID(ctx)
	case history.FieldLink:
		return m.OldLink(ctx)
	case history.FieldStatus:
		return m.OldStatus(ctx)
	case history.FieldSaved:
		return m.OldSaved(ctx)
	}
	return nil, fmt.Errorf("unknown History field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case history.FieldMediaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaID(v)
		return nil
	case history.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpisodeID(v)
		return nil
	case history.FieldSourceTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSourceTitle(v)
		return nil
	case history.FieldDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDate(v)
		return nil
	case history.FieldTargetDir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDir(v)
		return nil
	case history.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case history.FieldDownloadClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadClientID(v)
		return nil
	case history.FieldIndexerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexerID(v)
		return nil
	case history.FieldLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLink(v)
		return nil
	case history.FieldStatus:
		v, ok := value.(history.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case history.FieldSaved:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSaved(v)
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HistoryMutation) AddedFields() []string {
	var fields []string
	if m.addmedia_id != nil {
		fields = append(fields, history.FieldMediaID)
	}
	if m.addepisode_id != nil {
		fields = append(fields, history.FieldEpisodeID)
	}
	if m.addsize != nil {
		fields = append(fields, history.FieldSize)
	}
	if m.adddownload_client_id != nil {
		fields = append(fields, history.FieldDownloadClientID)
	}
	if m.addindexer_id != nil {
		fields = append(fields, history.FieldIndexerID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HistoryMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case history.FieldMediaID:
		return m.AddedMediaID()
	case history.FieldEpisodeID:
		return m.AddedEpisodeID()
	case history.FieldSize:
		return m.AddedSize()
	case history.FieldDownloadClientID:
		return m.AddedDownloadClientID()
	case history.FieldIndexerID:
		return m.AddedIndexerID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	case history.FieldMediaID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMediaID(v)
		return nil
	case history.FieldEpisodeID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEpisodeID(v)
		return nil
	case history.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case history.FieldDownloadClientID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDownloadClientID(v)
		return nil
	case history.FieldIndexerID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddIndexerID(v)
		return nil
	}
	return fmt.Errorf("unknown History numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HistoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(history.FieldEpisodeID) {
		fields = append(fields, history.FieldEpisodeID)
	}
	if m.FieldCleared(history.FieldDownloadClientID) {
		fields = append(fields, history.FieldDownloadClientID)
	}
	if m.FieldCleared(history.FieldIndexerID) {
		fields = append(fields, history.FieldIndexerID)
	}
	if m.FieldCleared(history.FieldLink) {
		fields = append(fields, history.FieldLink)
	}
	if m.FieldCleared(history.FieldSaved) {
		fields = append(fields, history.FieldSaved)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistoryMutation) ClearField(name string) error {
	switch name {
	case history.FieldEpisodeID:
		m.ClearEpisodeID()
		return nil
	case history.FieldDownloadClientID:
		m.ClearDownloadClientID()
		return nil
	case history.FieldIndexerID:
		m.ClearIndexerID()
		return nil
	case history.FieldLink:
		m.ClearLink()
		return nil
	case history.FieldSaved:
		m.ClearSaved()
		return nil
	}
	return fmt.Errorf("unknown History nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HistoryMutation) ResetField(name string) error {
	switch name {
	case history.FieldMediaID:
		m.ResetMediaID()
		return nil
	case history.FieldEpisodeID:
		m.ResetEpisodeID()
		return nil
	case history.FieldSourceTitle:
		m.ResetSourceTitle()
		return nil
	case history.FieldDate:
		m.ResetDate()
		return nil
	case history.FieldTargetDir:
		m.ResetTargetDir()
		return nil
	case history.FieldSize:
		m.ResetSize()
		return nil
	case history.FieldDownloadClientID:
		m.ResetDownloadClientID()
		return nil
	case history.FieldIndexerID:
		m.ResetIndexerID()
		return nil
	case history.FieldLink:
		m.ResetLink()
		return nil
	case history.FieldStatus:
		m.ResetStatus()
		return nil
	case history.FieldSaved:
		m.ResetSaved()
		return nil
	}
	return fmt.Errorf("unknown History field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HistoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HistoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HistoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown History unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HistoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown History edge %s", name)
}

// ImportListMutation represents an operation that mutates the ImportList nodes in the graph.
type ImportListMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	_type         *importlist.Type
	url           *string
	qulity        *string
	storage_id    *int
	addstorage_id *int
	settings      *schema.ImportListSettings
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*ImportList, error)
	predicates    []predicate.ImportList
}

var _ ent.Mutation = (*ImportListMutation)(nil)

// importlistOption allows management of the mutation configuration using functional options.
type importlistOption func(*ImportListMutation)

// newImportListMutation creates new mutation for the ImportList entity.
func newImportListMutation(c config, op Op, opts ...importlistOption) *ImportListMutation {
	m := &ImportListMutation{
		config:        c,
		op:            op,
		typ:           TypeImportList,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withImportListID sets the ID field of the mutation.
func withImportListID(id int) importlistOption {
	return func(m *ImportListMutation) {
		var (
			err   error
			once  sync.Once
			value *ImportList
		)
		m.oldValue = func(ctx context.Context) (*ImportList, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ImportList.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withImportList sets the old ImportList of the mutation.
func withImportList(node *ImportList) importlistOption {
	return func(m *ImportListMutation) {
		m.oldValue = func(context.Context) (*ImportList, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ImportListMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ImportListMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ImportListMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ImportListMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ImportList.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ImportListMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ImportListMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ImportListMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *ImportListMutation) SetType(i importlist.Type) {
	m._type = &i
}

// GetType returns the value of the "type" field in the mutation.
func (m *ImportListMutation) GetType() (r importlist.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldType(ctx context.Context) (v importlist.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ImportListMutation) ResetType() {
	m._type = nil
}

// SetURL sets the "url" field.
func (m *ImportListMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ImportListMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ClearURL clears the value of the "url" field.
func (m *ImportListMutation) ClearURL() {
	m.url = nil
	m.clearedFields[importlist.FieldURL] = struct{}{}
}

// URLCleared returns if the "url" field was cleared in this mutation.
func (m *ImportListMutation) URLCleared() bool {
	_, ok := m.clearedFields[importlist.FieldURL]
	return ok
}

// ResetURL resets all changes to the "url" field.
func (m *ImportListMutation) ResetURL() {
	m.url = nil
	delete(m.clearedFields, importlist.FieldURL)
}

// SetQulity sets the "qulity" field.
func (m *ImportListMutation) SetQulity(s string) {
	m.qulity = &s
}

// Qulity returns the value of the "qulity" field in the mutation.
func (m *ImportListMutation) Qulity() (r string, exists bool) {
	v := m.qulity
	if v == nil {
		return
	}
	return *v, true
}

// OldQulity returns the old "qulity" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldQulity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQulity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQulity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQulity: %w", err)
	}
	return oldValue.Qulity, nil
}

// ResetQulity resets all changes to the "qulity" field.
func (m *ImportListMutation) ResetQulity() {
	m.qulity = nil
}

// SetStorageID sets the "storage_id" field.
func (m *ImportListMutation) SetStorageID(i int) {
	m.storage_id = &i
	m.addstorage_id = nil
}

// StorageID returns the value of the "storage_id" field in the mutation.
func (m *ImportListMutation) StorageID() (r int, exists bool) {
	v := m.storage_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageID returns the old "storage_id" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageID: %w", err)
	}
	return oldValue.StorageID, nil
}

// AddStorageID adds i to the "storage_id" field.
func (m *ImportListMutation) AddStorageID(i int) {
	if m.addstorage_id != nil {
		*m.addstorage_id += i
	} else {
		m.addstorage_id = &i
	}
}

// AddedStorageID returns the value that was added to the "storage_id" field in this mutation.
func (m *ImportListMutation) AddedStorageID() (r int, exists bool) {
	v := m.addstorage_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetStorageID resets all changes to the "storage_id" field.
func (m *ImportListMutation) ResetStorageID() {
	m.storage_id = nil
	m.addstorage_id = nil
}

// SetSettings sets the "settings" field.
func (m *ImportListMutation) SetSettings(sls schema.ImportListSettings) {
	m.settings = &sls
}

// Settings returns the value of the "settings" field in the mutation.
func (m *ImportListMutation) Settings() (r schema.ImportListSettings, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the ImportList entity.
// If the ImportList object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ImportListMutation) OldSettings(ctx context.Context) (v schema.ImportListSettings, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *ImportListMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[importlist.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *ImportListMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[importlist.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *ImportListMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, importlist.FieldSettings)
}

// Where appends a list predicates to the ImportListMutation builder.
func (m *ImportListMutation) Where(ps ...predicate.ImportList) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ImportListMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ImportListMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ImportList, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ImportListMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ImportListMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ImportList).
func (m *ImportListMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ImportListMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, importlist.FieldName)
	}
	if m._type != nil {
		fields = append(fields, importlist.FieldType)
	}
	if m.url != nil {
		fields = append(fields, importlist.FieldURL)
	}
	if m.qulity != nil {
		fields = append(fields, importlist.FieldQulity)
	}
	if m.storage_id != nil {
		fields = append(fields, importlist.FieldStorageID)
	}
	if m.settings != nil {
		fields = append(fields, importlist.FieldSettings)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ImportListMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case importlist.FieldName:
		return m.Name()
	case importlist.FieldType:
		return m.GetType()
	case importlist.FieldURL:
		return m.URL()
	case importlist.FieldQulity:
		return m.Qulity()
	case importlist.FieldStorageID:
		return m.StorageID()
	case importlist.FieldSettings:
		return m.Settings()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ImportListMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case importlist.FieldName:
		return m.OldName(ctx)
	case importlist.FieldType:
		return m.OldType(ctx)
	case importlist.FieldURL:
		return m.OldURL(ctx)
	case importlist.FieldQulity:
		return m.OldQulity(ctx)
	case importlist.FieldStorageID:
		return m.OldStorageID(ctx)
	case importlist.FieldSettings:
		return m.OldSettings(ctx)
	}
	return nil, fmt.Errorf("unknown ImportList field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportListMutation) SetField(name string, value ent.Value) error {
	switch name {
	case importlist.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case importlist.FieldType:
		v, ok := value.(importlist.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case importlist.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case importlist.FieldQulity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQulity(v)
		return nil
	case importlist.FieldStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageID(v)
		return nil
	case importlist.FieldSettings:
		v, ok := value.(schema.ImportListSettings)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	}
	return fmt.Errorf("unknown ImportList field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ImportListMutation) AddedFields() []string {
	var fields []string
	if m.addstorage_id != nil {
		fields = append(fields, importlist.FieldStorageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ImportListMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case importlist.FieldStorageID:
		return m.AddedStorageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ImportListMutation) AddField(name string, value ent.Value) error {
	switch name {
	case importlist.FieldStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageID(v)
		return nil
	}
	return fmt.Errorf("unknown ImportList numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ImportListMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(importlist.FieldURL) {
		fields = append(fields, importlist.FieldURL)
	}
	if m.FieldCleared(importlist.FieldSettings) {
		fields = append(fields, importlist.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ImportListMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ImportListMutation) ClearField(name string) error {
	switch name {
	case importlist.FieldURL:
		m.ClearURL()
		return nil
	case importlist.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown ImportList nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ImportListMutation) ResetField(name string) error {
	switch name {
	case importlist.FieldName:
		m.ResetName()
		return nil
	case importlist.FieldType:
		m.ResetType()
		return nil
	case importlist.FieldURL:
		m.ResetURL()
		return nil
	case importlist.FieldQulity:
		m.ResetQulity()
		return nil
	case importlist.FieldStorageID:
		m.ResetStorageID()
		return nil
	case importlist.FieldSettings:
		m.ResetSettings()
		return nil
	}
	return fmt.Errorf("unknown ImportList field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ImportListMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ImportListMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ImportListMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ImportListMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ImportListMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ImportListMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ImportListMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown ImportList unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ImportListMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown ImportList edge %s", name)
}

// IndexersMutation represents an operation that mutates the Indexers nodes in the graph.
type IndexersMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	implementation *string
	settings       *string
	enable_rss     *bool
	priority       *int
	addpriority    *int
	seed_ratio     *float32
	addseed_ratio  *float32
	disabled       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Indexers, error)
	predicates     []predicate.Indexers
}

var _ ent.Mutation = (*IndexersMutation)(nil)

// indexersOption allows management of the mutation configuration using functional options.
type indexersOption func(*IndexersMutation)

// newIndexersMutation creates new mutation for the Indexers entity.
func newIndexersMutation(c config, op Op, opts ...indexersOption) *IndexersMutation {
	m := &IndexersMutation{
		config:        c,
		op:            op,
		typ:           TypeIndexers,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withIndexersID sets the ID field of the mutation.
func withIndexersID(id int) indexersOption {
	return func(m *IndexersMutation) {
		var (
			err   error
			once  sync.Once
			value *Indexers
		)
		m.oldValue = func(ctx context.Context) (*Indexers, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Indexers.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withIndexers sets the old Indexers of the mutation.
func withIndexers(node *Indexers) indexersOption {
	return func(m *IndexersMutation) {
		m.oldValue = func(context.Context) (*Indexers, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m IndexersMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m IndexersMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *IndexersMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *IndexersMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Indexers.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *IndexersMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *IndexersMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *IndexersMutation) ResetName() {
	m.name = nil
}

// SetImplementation sets the "implementation" field.
func (m *IndexersMutation) SetImplementation(s string) {
	m.implementation = &s
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *IndexersMutation) Implementation() (r string, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldImplementation(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *IndexersMutation) ResetImplementation() {
	m.implementation = nil
}

// SetSettings sets the "settings" field.
func (m *IndexersMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *IndexersMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *IndexersMutation) ResetSettings() {
	m.settings = nil
}

// SetEnableRss sets the "enable_rss" field.
func (m *IndexersMutation) SetEnableRss(b bool) {
	m.enable_rss = &b
}

// EnableRss returns the value of the "enable_rss" field in the mutation.
func (m *IndexersMutation) EnableRss() (r bool, exists bool) {
	v := m.enable_rss
	if v == nil {
		return
	}
	return *v, true
}

// OldEnableRss returns the old "enable_rss" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldEnableRss(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnableRss is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnableRss requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnableRss: %w", err)
	}
	return oldValue.EnableRss, nil
}

// ResetEnableRss resets all changes to the "enable_rss" field.
func (m *IndexersMutation) ResetEnableRss() {
	m.enable_rss = nil
}

// SetPriority sets the "priority" field.
func (m *IndexersMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *IndexersMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *IndexersMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *IndexersMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *IndexersMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// SetSeedRatio sets the "seed_ratio" field.
func (m *IndexersMutation) SetSeedRatio(f float32) {
	m.seed_ratio = &f
	m.addseed_ratio = nil
}

// SeedRatio returns the value of the "seed_ratio" field in the mutation.
func (m *IndexersMutation) SeedRatio() (r float32, exists bool) {
	v := m.seed_ratio
	if v == nil {
		return
	}
	return *v, true
}

// OldSeedRatio returns the old "seed_ratio" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldSeedRatio(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeedRatio is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeedRatio requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeedRatio: %w", err)
	}
	return oldValue.SeedRatio, nil
}

// AddSeedRatio adds f to the "seed_ratio" field.
func (m *IndexersMutation) AddSeedRatio(f float32) {
	if m.addseed_ratio != nil {
		*m.addseed_ratio += f
	} else {
		m.addseed_ratio = &f
	}
}

// AddedSeedRatio returns the value that was added to the "seed_ratio" field in this mutation.
func (m *IndexersMutation) AddedSeedRatio() (r float32, exists bool) {
	v := m.addseed_ratio
	if v == nil {
		return
	}
	return *v, true
}

// ClearSeedRatio clears the value of the "seed_ratio" field.
func (m *IndexersMutation) ClearSeedRatio() {
	m.seed_ratio = nil
	m.addseed_ratio = nil
	m.clearedFields[indexers.FieldSeedRatio] = struct{}{}
}

// SeedRatioCleared returns if the "seed_ratio" field was cleared in this mutation.
func (m *IndexersMutation) SeedRatioCleared() bool {
	_, ok := m.clearedFields[indexers.FieldSeedRatio]
	return ok
}

// ResetSeedRatio resets all changes to the "seed_ratio" field.
func (m *IndexersMutation) ResetSeedRatio() {
	m.seed_ratio = nil
	m.addseed_ratio = nil
	delete(m.clearedFields, indexers.FieldSeedRatio)
}

// SetDisabled sets the "disabled" field.
func (m *IndexersMutation) SetDisabled(b bool) {
	m.disabled = &b
}

// Disabled returns the value of the "disabled" field in the mutation.
func (m *IndexersMutation) Disabled() (r bool, exists bool) {
	v := m.disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldDisabled returns the old "disabled" field's value of the Indexers entity.
// If the Indexers object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *IndexersMutation) OldDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisabled: %w", err)
	}
	return oldValue.Disabled, nil
}

// ClearDisabled clears the value of the "disabled" field.
func (m *IndexersMutation) ClearDisabled() {
	m.disabled = nil
	m.clearedFields[indexers.FieldDisabled] = struct{}{}
}

// DisabledCleared returns if the "disabled" field was cleared in this mutation.
func (m *IndexersMutation) DisabledCleared() bool {
	_, ok := m.clearedFields[indexers.FieldDisabled]
	return ok
}

// ResetDisabled resets all changes to the "disabled" field.
func (m *IndexersMutation) ResetDisabled() {
	m.disabled = nil
	delete(m.clearedFields, indexers.FieldDisabled)
}

// Where appends a list predicates to the IndexersMutation builder.
func (m *IndexersMutation) Where(ps ...predicate.Indexers) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the IndexersMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *IndexersMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Indexers, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *IndexersMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *IndexersMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Indexers).
func (m *IndexersMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *IndexersMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, indexers.FieldName)
	}
	if m.implementation != nil {
		fields = append(fields, indexers.FieldImplementation)
	}
	if m.settings != nil {
		fields = append(fields, indexers.FieldSettings)
	}
	if m.enable_rss != nil {
		fields = append(fields, indexers.FieldEnableRss)
	}
	if m.priority != nil {
		fields = append(fields, indexers.FieldPriority)
	}
	if m.seed_ratio != nil {
		fields = append(fields, indexers.FieldSeedRatio)
	}
	if m.disabled != nil {
		fields = append(fields, indexers.FieldDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *IndexersMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case indexers.FieldName:
		return m.Name()
	case indexers.FieldImplementation:
		return m.Implementation()
	case indexers.FieldSettings:
		return m.Settings()
	case indexers.FieldEnableRss:
		return m.EnableRss()
	case indexers.FieldPriority:
		return m.Priority()
	case indexers.FieldSeedRatio:
		return m.SeedRatio()
	case indexers.FieldDisabled:
		return m.Disabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *IndexersMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case indexers.FieldName:
		return m.OldName(ctx)
	case indexers.FieldImplementation:
		return m.OldImplementation(ctx)
	case indexers.FieldSettings:
		return m.OldSettings(ctx)
	case indexers.FieldEnableRss:
		return m.OldEnableRss(ctx)
	case indexers.FieldPriority:
		return m.OldPriority(ctx)
	case indexers.FieldSeedRatio:
		return m.OldSeedRatio(ctx)
	case indexers.FieldDisabled:
		return m.OldDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown Indexers field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndexersMutation) SetField(name string, value ent.Value) error {
	switch name {
	case indexers.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case indexers.FieldImplementation:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case indexers.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case indexers.FieldEnableRss:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnableRss(v)
		return nil
	case indexers.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	case indexers.FieldSeedRatio:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeedRatio(v)
		return nil
	case indexers.FieldDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown Indexers field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *IndexersMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, indexers.FieldPriority)
	}
	if m.addseed_ratio != nil {
		fields = append(fields, indexers.FieldSeedRatio)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *IndexersMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case indexers.FieldPriority:
		return m.AddedPriority()
	case indexers.FieldSeedRatio:
		return m.AddedSeedRatio()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *IndexersMutation) AddField(name string, value ent.Value) error {
	switch name {
	case indexers.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	case indexers.FieldSeedRatio:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSeedRatio(v)
		return nil
	}
	return fmt.Errorf("unknown Indexers numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *IndexersMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(indexers.FieldSeedRatio) {
		fields = append(fields, indexers.FieldSeedRatio)
	}
	if m.FieldCleared(indexers.FieldDisabled) {
		fields = append(fields, indexers.FieldDisabled)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *IndexersMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *IndexersMutation) ClearField(name string) error {
	switch name {
	case indexers.FieldSeedRatio:
		m.ClearSeedRatio()
		return nil
	case indexers.FieldDisabled:
		m.ClearDisabled()
		return nil
	}
	return fmt.Errorf("unknown Indexers nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *IndexersMutation) ResetField(name string) error {
	switch name {
	case indexers.FieldName:
		m.ResetName()
		return nil
	case indexers.FieldImplementation:
		m.ResetImplementation()
		return nil
	case indexers.FieldSettings:
		m.ResetSettings()
		return nil
	case indexers.FieldEnableRss:
		m.ResetEnableRss()
		return nil
	case indexers.FieldPriority:
		m.ResetPriority()
		return nil
	case indexers.FieldSeedRatio:
		m.ResetSeedRatio()
		return nil
	case indexers.FieldDisabled:
		m.ResetDisabled()
		return nil
	}
	return fmt.Errorf("unknown Indexers field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *IndexersMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *IndexersMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *IndexersMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *IndexersMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *IndexersMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *IndexersMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *IndexersMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Indexers unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *IndexersMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Indexers edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                        Op
	typ                       string
	id                        *int
	tmdb_id                   *int
	addtmdb_id                *int
	imdb_id                   *string
	media_type                *media.MediaType
	name_cn                   *string
	name_en                   *string
	original_name             *string
	overview                  *string
	created_at                *time.Time
	air_date                  *string
	resolution                *media.Resolution
	storage_id                *int
	addstorage_id             *int
	target_dir                *string
	download_history_episodes *bool
	limiter                   *schema.MediaLimiter
	extras                    *schema.MediaExtras
	clearedFields             map[string]struct{}
	episodes                  map[int]struct{}
	removedepisodes           map[int]struct{}
	clearedepisodes           bool
	done                      bool
	oldValue                  func(context.Context) (*Media, error)
	predicates                []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id int) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTmdbID sets the "tmdb_id" field.
func (m *MediaMutation) SetTmdbID(i int) {
	m.tmdb_id = &i
	m.addtmdb_id = nil
}

// TmdbID returns the value of the "tmdb_id" field in the mutation.
func (m *MediaMutation) TmdbID() (r int, exists bool) {
	v := m.tmdb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTmdbID returns the old "tmdb_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldTmdbID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTmdbID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTmdbID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTmdbID: %w", err)
	}
	return oldValue.TmdbID, nil
}

// AddTmdbID adds i to the "tmdb_id" field.
func (m *MediaMutation) AddTmdbID(i int) {
	if m.addtmdb_id != nil {
		*m.addtmdb_id += i
	} else {
		m.addtmdb_id = &i
	}
}

// AddedTmdbID returns the value that was added to the "tmdb_id" field in this mutation.
func (m *MediaMutation) AddedTmdbID() (r int, exists bool) {
	v := m.addtmdb_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTmdbID resets all changes to the "tmdb_id" field.
func (m *MediaMutation) ResetTmdbID() {
	m.tmdb_id = nil
	m.addtmdb_id = nil
}

// SetImdbID sets the "imdb_id" field.
func (m *MediaMutation) SetImdbID(s string) {
	m.imdb_id = &s
}

// ImdbID returns the value of the "imdb_id" field in the mutation.
func (m *MediaMutation) ImdbID() (r string, exists bool) {
	v := m.imdb_id
	if v == nil {
		return
	}
	return *v, true
}

// OldImdbID returns the old "imdb_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldImdbID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImdbID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImdbID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImdbID: %w", err)
	}
	return oldValue.ImdbID, nil
}

// ClearImdbID clears the value of the "imdb_id" field.
func (m *MediaMutation) ClearImdbID() {
	m.imdb_id = nil
	m.clearedFields[media.FieldImdbID] = struct{}{}
}

// ImdbIDCleared returns if the "imdb_id" field was cleared in this mutation.
func (m *MediaMutation) ImdbIDCleared() bool {
	_, ok := m.clearedFields[media.FieldImdbID]
	return ok
}

// ResetImdbID resets all changes to the "imdb_id" field.
func (m *MediaMutation) ResetImdbID() {
	m.imdb_id = nil
	delete(m.clearedFields, media.FieldImdbID)
}

// SetMediaType sets the "media_type" field.
func (m *MediaMutation) SetMediaType(mt media.MediaType) {
	m.media_type = &mt
}

// MediaType returns the value of the "media_type" field in the mutation.
func (m *MediaMutation) MediaType() (r media.MediaType, exists bool) {
	v := m.media_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaType returns the old "media_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMediaType(ctx context.Context) (v media.MediaType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaType: %w", err)
	}
	return oldValue.MediaType, nil
}

// ResetMediaType resets all changes to the "media_type" field.
func (m *MediaMutation) ResetMediaType() {
	m.media_type = nil
}

// SetNameCn sets the "name_cn" field.
func (m *MediaMutation) SetNameCn(s string) {
	m.name_cn = &s
}

// NameCn returns the value of the "name_cn" field in the mutation.
func (m *MediaMutation) NameCn() (r string, exists bool) {
	v := m.name_cn
	if v == nil {
		return
	}
	return *v, true
}

// OldNameCn returns the old "name_cn" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldNameCn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameCn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameCn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameCn: %w", err)
	}
	return oldValue.NameCn, nil
}

// ResetNameCn resets all changes to the "name_cn" field.
func (m *MediaMutation) ResetNameCn() {
	m.name_cn = nil
}

// SetNameEn sets the "name_en" field.
func (m *MediaMutation) SetNameEn(s string) {
	m.name_en = &s
}

// NameEn returns the value of the "name_en" field in the mutation.
func (m *MediaMutation) NameEn() (r string, exists bool) {
	v := m.name_en
	if v == nil {
		return
	}
	return *v, true
}

// OldNameEn returns the old "name_en" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldNameEn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNameEn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNameEn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNameEn: %w", err)
	}
	return oldValue.NameEn, nil
}

// ResetNameEn resets all changes to the "name_en" field.
func (m *MediaMutation) ResetNameEn() {
	m.name_en = nil
}

// SetOriginalName sets the "original_name" field.
func (m *MediaMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *MediaMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *MediaMutation) ResetOriginalName() {
	m.original_name = nil
}

// SetOverview sets the "overview" field.
func (m *MediaMutation) SetOverview(s string) {
	m.overview = &s
}

// Overview returns the value of the "overview" field in the mutation.
func (m *MediaMutation) Overview() (r string, exists bool) {
	v := m.overview
	if v == nil {
		return
	}
	return *v, true
}

// OldOverview returns the old "overview" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOverview(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverview is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverview requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverview: %w", err)
	}
	return oldValue.Overview, nil
}

// ResetOverview resets all changes to the "overview" field.
func (m *MediaMutation) ResetOverview() {
	m.overview = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *MediaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MediaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MediaMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetAirDate sets the "air_date" field.
func (m *MediaMutation) SetAirDate(s string) {
	m.air_date = &s
}

// AirDate returns the value of the "air_date" field in the mutation.
func (m *MediaMutation) AirDate() (r string, exists bool) {
	v := m.air_date
	if v == nil {
		return
	}
	return *v, true
}

// OldAirDate returns the old "air_date" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAirDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAirDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAirDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAirDate: %w", err)
	}
	return oldValue.AirDate, nil
}

// ResetAirDate resets all changes to the "air_date" field.
func (m *MediaMutation) ResetAirDate() {
	m.air_date = nil
}

// SetResolution sets the "resolution" field.
func (m *MediaMutation) SetResolution(value media.Resolution) {
	m.resolution = &value
}

// Resolution returns the value of the "resolution" field in the mutation.
func (m *MediaMutation) Resolution() (r media.Resolution, exists bool) {
	v := m.resolution
	if v == nil {
		return
	}
	return *v, true
}

// OldResolution returns the old "resolution" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldResolution(ctx context.Context) (v media.Resolution, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResolution is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResolution requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResolution: %w", err)
	}
	return oldValue.Resolution, nil
}

// ResetResolution resets all changes to the "resolution" field.
func (m *MediaMutation) ResetResolution() {
	m.resolution = nil
}

// SetStorageID sets the "storage_id" field.
func (m *MediaMutation) SetStorageID(i int) {
	m.storage_id = &i
	m.addstorage_id = nil
}

// StorageID returns the value of the "storage_id" field in the mutation.
func (m *MediaMutation) StorageID() (r int, exists bool) {
	v := m.storage_id
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageID returns the old "storage_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldStorageID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageID: %w", err)
	}
	return oldValue.StorageID, nil
}

// AddStorageID adds i to the "storage_id" field.
func (m *MediaMutation) AddStorageID(i int) {
	if m.addstorage_id != nil {
		*m.addstorage_id += i
	} else {
		m.addstorage_id = &i
	}
}

// AddedStorageID returns the value that was added to the "storage_id" field in this mutation.
func (m *MediaMutation) AddedStorageID() (r int, exists bool) {
	v := m.addstorage_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearStorageID clears the value of the "storage_id" field.
func (m *MediaMutation) ClearStorageID() {
	m.storage_id = nil
	m.addstorage_id = nil
	m.clearedFields[media.FieldStorageID] = struct{}{}
}

// StorageIDCleared returns if the "storage_id" field was cleared in this mutation.
func (m *MediaMutation) StorageIDCleared() bool {
	_, ok := m.clearedFields[media.FieldStorageID]
	return ok
}

// ResetStorageID resets all changes to the "storage_id" field.
func (m *MediaMutation) ResetStorageID() {
	m.storage_id = nil
	m.addstorage_id = nil
	delete(m.clearedFields, media.FieldStorageID)
}

// SetTargetDir sets the "target_dir" field.
func (m *MediaMutation) SetTargetDir(s string) {
	m.target_dir = &s
}

// TargetDir returns the value of the "target_dir" field in the mutation.
func (m *MediaMutation) TargetDir() (r string, exists bool) {
	v := m.target_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldTargetDir returns the old "target_dir" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldTargetDir(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTargetDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTargetDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTargetDir: %w", err)
	}
	return oldValue.TargetDir, nil
}

// ClearTargetDir clears the value of the "target_dir" field.
func (m *MediaMutation) ClearTargetDir() {
	m.target_dir = nil
	m.clearedFields[media.FieldTargetDir] = struct{}{}
}

// TargetDirCleared returns if the "target_dir" field was cleared in this mutation.
func (m *MediaMutation) TargetDirCleared() bool {
	_, ok := m.clearedFields[media.FieldTargetDir]
	return ok
}

// ResetTargetDir resets all changes to the "target_dir" field.
func (m *MediaMutation) ResetTargetDir() {
	m.target_dir = nil
	delete(m.clearedFields, media.FieldTargetDir)
}

// SetDownloadHistoryEpisodes sets the "download_history_episodes" field.
func (m *MediaMutation) SetDownloadHistoryEpisodes(b bool) {
	m.download_history_episodes = &b
}

// DownloadHistoryEpisodes returns the value of the "download_history_episodes" field in the mutation.
func (m *MediaMutation) DownloadHistoryEpisodes() (r bool, exists bool) {
	v := m.download_history_episodes
	if v == nil {
		return
	}
	return *v, true
}

// OldDownloadHistoryEpisodes returns the old "download_history_episodes" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDownloadHistoryEpisodes(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDownloadHistoryEpisodes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDownloadHistoryEpisodes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDownloadHistoryEpisodes: %w", err)
	}
	return oldValue.DownloadHistoryEpisodes, nil
}

// ClearDownloadHistoryEpisodes clears the value of the "download_history_episodes" field.
func (m *MediaMutation) ClearDownloadHistoryEpisodes() {
	m.download_history_episodes = nil
	m.clearedFields[media.FieldDownloadHistoryEpisodes] = struct{}{}
}

// DownloadHistoryEpisodesCleared returns if the "download_history_episodes" field was cleared in this mutation.
func (m *MediaMutation) DownloadHistoryEpisodesCleared() bool {
	_, ok := m.clearedFields[media.FieldDownloadHistoryEpisodes]
	return ok
}

// ResetDownloadHistoryEpisodes resets all changes to the "download_history_episodes" field.
func (m *MediaMutation) ResetDownloadHistoryEpisodes() {
	m.download_history_episodes = nil
	delete(m.clearedFields, media.FieldDownloadHistoryEpisodes)
}

// SetLimiter sets the "limiter" field.
func (m *MediaMutation) SetLimiter(sl schema.MediaLimiter) {
	m.limiter = &sl
}

// Limiter returns the value of the "limiter" field in the mutation.
func (m *MediaMutation) Limiter() (r schema.MediaLimiter, exists bool) {
	v := m.limiter
	if v == nil {
		return
	}
	return *v, true
}

// OldLimiter returns the old "limiter" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldLimiter(ctx context.Context) (v schema.MediaLimiter, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLimiter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLimiter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLimiter: %w", err)
	}
	return oldValue.Limiter, nil
}

// ClearLimiter clears the value of the "limiter" field.
func (m *MediaMutation) ClearLimiter() {
	m.limiter = nil
	m.clearedFields[media.FieldLimiter] = struct{}{}
}

// LimiterCleared returns if the "limiter" field was cleared in this mutation.
func (m *MediaMutation) LimiterCleared() bool {
	_, ok := m.clearedFields[media.FieldLimiter]
	return ok
}

// ResetLimiter resets all changes to the "limiter" field.
func (m *MediaMutation) ResetLimiter() {
	m.limiter = nil
	delete(m.clearedFields, media.FieldLimiter)
}

// SetExtras sets the "extras" field.
func (m *MediaMutation) SetExtras(se schema.MediaExtras) {
	m.extras = &se
}

// Extras returns the value of the "extras" field in the mutation.
func (m *MediaMutation) Extras() (r schema.MediaExtras, exists bool) {
	v := m.extras
	if v == nil {
		return
	}
	return *v, true
}

// OldExtras returns the old "extras" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldExtras(ctx context.Context) (v schema.MediaExtras, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtras is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtras requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtras: %w", err)
	}
	return oldValue.Extras, nil
}

// ClearExtras clears the value of the "extras" field.
func (m *MediaMutation) ClearExtras() {
	m.extras = nil
	m.clearedFields[media.FieldExtras] = struct{}{}
}

// ExtrasCleared returns if the "extras" field was cleared in this mutation.
func (m *MediaMutation) ExtrasCleared() bool {
	_, ok := m.clearedFields[media.FieldExtras]
	return ok
}

// ResetExtras resets all changes to the "extras" field.
func (m *MediaMutation) ResetExtras() {
	m.extras = nil
	delete(m.clearedFields, media.FieldExtras)
}

// AddEpisodeIDs adds the "episodes" edge to the Episode entity by ids.
func (m *MediaMutation) AddEpisodeIDs(ids ...int) {
	if m.episodes == nil {
		m.episodes = make(map[int]struct{})
	}
	for i := range ids {
		m.episodes[ids[i]] = struct{}{}
	}
}

// ClearEpisodes clears the "episodes" edge to the Episode entity.
func (m *MediaMutation) ClearEpisodes() {
	m.clearedepisodes = true
}

// EpisodesCleared reports if the "episodes" edge to the Episode entity was cleared.
func (m *MediaMutation) EpisodesCleared() bool {
	return m.clearedepisodes
}

// RemoveEpisodeIDs removes the "episodes" edge to the Episode entity by IDs.
func (m *MediaMutation) RemoveEpisodeIDs(ids ...int) {
	if m.removedepisodes == nil {
		m.removedepisodes = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.episodes, ids[i])
		m.removedepisodes[ids[i]] = struct{}{}
	}
}

// RemovedEpisodes returns the removed IDs of the "episodes" edge to the Episode entity.
func (m *MediaMutation) RemovedEpisodesIDs() (ids []int) {
	for id := range m.removedepisodes {
		ids = append(ids, id)
	}
	return
}

// EpisodesIDs returns the "episodes" edge IDs in the mutation.
func (m *MediaMutation) EpisodesIDs() (ids []int) {
	for id := range m.episodes {
		ids = append(ids, id)
	}
	return
}

// ResetEpisodes resets all changes to the "episodes" edge.
func (m *MediaMutation) ResetEpisodes() {
	m.episodes = nil
	m.clearedepisodes = false
	m.removedepisodes = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 15)
	if m.tmdb_id != nil {
		fields = append(fields, media.FieldTmdbID)
	}
	if m.imdb_id != nil {
		fields = append(fields, media.FieldImdbID)
	}
	if m.media_type != nil {
		fields = append(fields, media.FieldMediaType)
	}
	if m.name_cn != nil {
		fields = append(fields, media.FieldNameCn)
	}
	if m.name_en != nil {
		fields = append(fields, media.FieldNameEn)
	}
	if m.original_name != nil {
		fields = append(fields, media.FieldOriginalName)
	}
	if m.overview != nil {
		fields = append(fields, media.FieldOverview)
	}
	if m.created_at != nil {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m.air_date != nil {
		fields = append(fields, media.FieldAirDate)
	}
	if m.resolution != nil {
		fields = append(fields, media.FieldResolution)
	}
	if m.storage_id != nil {
		fields = append(fields, media.FieldStorageID)
	}
	if m.target_dir != nil {
		fields = append(fields, media.FieldTargetDir)
	}
	if m.download_history_episodes != nil {
		fields = append(fields, media.FieldDownloadHistoryEpisodes)
	}
	if m.limiter != nil {
		fields = append(fields, media.FieldLimiter)
	}
	if m.extras != nil {
		fields = append(fields, media.FieldExtras)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldTmdbID:
		return m.TmdbID()
	case media.FieldImdbID:
		return m.ImdbID()
	case media.FieldMediaType:
		return m.MediaType()
	case media.FieldNameCn:
		return m.NameCn()
	case media.FieldNameEn:
		return m.NameEn()
	case media.FieldOriginalName:
		return m.OriginalName()
	case media.FieldOverview:
		return m.Overview()
	case media.FieldCreatedAt:
		return m.CreatedAt()
	case media.FieldAirDate:
		return m.AirDate()
	case media.FieldResolution:
		return m.Resolution()
	case media.FieldStorageID:
		return m.StorageID()
	case media.FieldTargetDir:
		return m.TargetDir()
	case media.FieldDownloadHistoryEpisodes:
		return m.DownloadHistoryEpisodes()
	case media.FieldLimiter:
		return m.Limiter()
	case media.FieldExtras:
		return m.Extras()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldTmdbID:
		return m.OldTmdbID(ctx)
	case media.FieldImdbID:
		return m.OldImdbID(ctx)
	case media.FieldMediaType:
		return m.OldMediaType(ctx)
	case media.FieldNameCn:
		return m.OldNameCn(ctx)
	case media.FieldNameEn:
		return m.OldNameEn(ctx)
	case media.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case media.FieldOverview:
		return m.OldOverview(ctx)
	case media.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case media.FieldAirDate:
		return m.OldAirDate(ctx)
	case media.FieldResolution:
		return m.OldResolution(ctx)
	case media.FieldStorageID:
		return m.OldStorageID(ctx)
	case media.FieldTargetDir:
		return m.OldTargetDir(ctx)
	case media.FieldDownloadHistoryEpisodes:
		return m.OldDownloadHistoryEpisodes(ctx)
	case media.FieldLimiter:
		return m.OldLimiter(ctx)
	case media.FieldExtras:
		return m.OldExtras(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldTmdbID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTmdbID(v)
		return nil
	case media.FieldImdbID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImdbID(v)
		return nil
	case media.FieldMediaType:
		v, ok := value.(media.MediaType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaType(v)
		return nil
	case media.FieldNameCn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameCn(v)
		return nil
	case media.FieldNameEn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNameEn(v)
		return nil
	case media.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case media.FieldOverview:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverview(v)
		return nil
	case media.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case media.FieldAirDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAirDate(v)
		return nil
	case media.FieldResolution:
		v, ok := value.(media.Resolution)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResolution(v)
		return nil
	case media.FieldStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageID(v)
		return nil
	case media.FieldTargetDir:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTargetDir(v)
		return nil
	case media.FieldDownloadHistoryEpisodes:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDownloadHistoryEpisodes(v)
		return nil
	case media.FieldLimiter:
		v, ok := value.(schema.MediaLimiter)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLimiter(v)
		return nil
	case media.FieldExtras:
		v, ok := value.(schema.MediaExtras)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtras(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	var fields []string
	if m.addtmdb_id != nil {
		fields = append(fields, media.FieldTmdbID)
	}
	if m.addstorage_id != nil {
		fields = append(fields, media.FieldStorageID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case media.FieldTmdbID:
		return m.AddedTmdbID()
	case media.FieldStorageID:
		return m.AddedStorageID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case media.FieldTmdbID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTmdbID(v)
		return nil
	case media.FieldStorageID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddStorageID(v)
		return nil
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(media.FieldImdbID) {
		fields = append(fields, media.FieldImdbID)
	}
	if m.FieldCleared(media.FieldStorageID) {
		fields = append(fields, media.FieldStorageID)
	}
	if m.FieldCleared(media.FieldTargetDir) {
		fields = append(fields, media.FieldTargetDir)
	}
	if m.FieldCleared(media.FieldDownloadHistoryEpisodes) {
		fields = append(fields, media.FieldDownloadHistoryEpisodes)
	}
	if m.FieldCleared(media.FieldLimiter) {
		fields = append(fields, media.FieldLimiter)
	}
	if m.FieldCleared(media.FieldExtras) {
		fields = append(fields, media.FieldExtras)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	switch name {
	case media.FieldImdbID:
		m.ClearImdbID()
		return nil
	case media.FieldStorageID:
		m.ClearStorageID()
		return nil
	case media.FieldTargetDir:
		m.ClearTargetDir()
		return nil
	case media.FieldDownloadHistoryEpisodes:
		m.ClearDownloadHistoryEpisodes()
		return nil
	case media.FieldLimiter:
		m.ClearLimiter()
		return nil
	case media.FieldExtras:
		m.ClearExtras()
		return nil
	}
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldTmdbID:
		m.ResetTmdbID()
		return nil
	case media.FieldImdbID:
		m.ResetImdbID()
		return nil
	case media.FieldMediaType:
		m.ResetMediaType()
		return nil
	case media.FieldNameCn:
		m.ResetNameCn()
		return nil
	case media.FieldNameEn:
		m.ResetNameEn()
		return nil
	case media.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case media.FieldOverview:
		m.ResetOverview()
		return nil
	case media.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case media.FieldAirDate:
		m.ResetAirDate()
		return nil
	case media.FieldResolution:
		m.ResetResolution()
		return nil
	case media.FieldStorageID:
		m.ResetStorageID()
		return nil
	case media.FieldTargetDir:
		m.ResetTargetDir()
		return nil
	case media.FieldDownloadHistoryEpisodes:
		m.ResetDownloadHistoryEpisodes()
		return nil
	case media.FieldLimiter:
		m.ResetLimiter()
		return nil
	case media.FieldExtras:
		m.ResetExtras()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.episodes != nil {
		edges = append(edges, media.EdgeEpisodes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.episodes))
		for id := range m.episodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedepisodes != nil {
		edges = append(edges, media.EdgeEpisodes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeEpisodes:
		ids := make([]ent.Value, 0, len(m.removedepisodes))
		for id := range m.removedepisodes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedepisodes {
		edges = append(edges, media.EdgeEpisodes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeEpisodes:
		return m.clearedepisodes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeEpisodes:
		m.ResetEpisodes()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// NotificationClientMutation represents an operation that mutates the NotificationClient nodes in the graph.
type NotificationClientMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	service       *string
	settings      *string
	enabled       *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*NotificationClient, error)
	predicates    []predicate.NotificationClient
}

var _ ent.Mutation = (*NotificationClientMutation)(nil)

// notificationclientOption allows management of the mutation configuration using functional options.
type notificationclientOption func(*NotificationClientMutation)

// newNotificationClientMutation creates new mutation for the NotificationClient entity.
func newNotificationClientMutation(c config, op Op, opts ...notificationclientOption) *NotificationClientMutation {
	m := &NotificationClientMutation{
		config:        c,
		op:            op,
		typ:           TypeNotificationClient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationClientID sets the ID field of the mutation.
func withNotificationClientID(id int) notificationclientOption {
	return func(m *NotificationClientMutation) {
		var (
			err   error
			once  sync.Once
			value *NotificationClient
		)
		m.oldValue = func(ctx context.Context) (*NotificationClient, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().NotificationClient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotificationClient sets the old NotificationClient of the mutation.
func withNotificationClient(node *NotificationClient) notificationclientOption {
	return func(m *NotificationClientMutation) {
		m.oldValue = func(context.Context) (*NotificationClient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationClientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationClientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationClientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationClientMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().NotificationClient.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *NotificationClientMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationClientMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the NotificationClient entity.
// If the NotificationClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationClientMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationClientMutation) ResetName() {
	m.name = nil
}

// SetService sets the "service" field.
func (m *NotificationClientMutation) SetService(s string) {
	m.service = &s
}

// Service returns the value of the "service" field in the mutation.
func (m *NotificationClientMutation) Service() (r string, exists bool) {
	v := m.service
	if v == nil {
		return
	}
	return *v, true
}

// OldService returns the old "service" field's value of the NotificationClient entity.
// If the NotificationClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationClientMutation) OldService(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldService is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldService requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldService: %w", err)
	}
	return oldValue.Service, nil
}

// ResetService resets all changes to the "service" field.
func (m *NotificationClientMutation) ResetService() {
	m.service = nil
}

// SetSettings sets the "settings" field.
func (m *NotificationClientMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *NotificationClientMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the NotificationClient entity.
// If the NotificationClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationClientMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ResetSettings resets all changes to the "settings" field.
func (m *NotificationClientMutation) ResetSettings() {
	m.settings = nil
}

// SetEnabled sets the "enabled" field.
func (m *NotificationClientMutation) SetEnabled(b bool) {
	m.enabled = &b
}

// Enabled returns the value of the "enabled" field in the mutation.
func (m *NotificationClientMutation) Enabled() (r bool, exists bool) {
	v := m.enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldEnabled returns the old "enabled" field's value of the NotificationClient entity.
// If the NotificationClient object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationClientMutation) OldEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEnabled: %w", err)
	}
	return oldValue.Enabled, nil
}

// ResetEnabled resets all changes to the "enabled" field.
func (m *NotificationClientMutation) ResetEnabled() {
	m.enabled = nil
}

// Where appends a list predicates to the NotificationClientMutation builder.
func (m *NotificationClientMutation) Where(ps ...predicate.NotificationClient) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationClientMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationClientMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.NotificationClient, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationClientMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationClientMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (NotificationClient).
func (m *NotificationClientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationClientMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, notificationclient.FieldName)
	}
	if m.service != nil {
		fields = append(fields, notificationclient.FieldService)
	}
	if m.settings != nil {
		fields = append(fields, notificationclient.FieldSettings)
	}
	if m.enabled != nil {
		fields = append(fields, notificationclient.FieldEnabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationClientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notificationclient.FieldName:
		return m.Name()
	case notificationclient.FieldService:
		return m.Service()
	case notificationclient.FieldSettings:
		return m.Settings()
	case notificationclient.FieldEnabled:
		return m.Enabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationClientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notificationclient.FieldName:
		return m.OldName(ctx)
	case notificationclient.FieldService:
		return m.OldService(ctx)
	case notificationclient.FieldSettings:
		return m.OldSettings(ctx)
	case notificationclient.FieldEnabled:
		return m.OldEnabled(ctx)
	}
	return nil, fmt.Errorf("unknown NotificationClient field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationClientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notificationclient.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notificationclient.FieldService:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetService(v)
		return nil
	case notificationclient.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case notificationclient.FieldEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEnabled(v)
		return nil
	}
	return fmt.Errorf("unknown NotificationClient field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationClientMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationClientMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationClientMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown NotificationClient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationClientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationClientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationClientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown NotificationClient nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationClientMutation) ResetField(name string) error {
	switch name {
	case notificationclient.FieldName:
		m.ResetName()
		return nil
	case notificationclient.FieldService:
		m.ResetService()
		return nil
	case notificationclient.FieldSettings:
		m.ResetSettings()
		return nil
	case notificationclient.FieldEnabled:
		m.ResetEnabled()
		return nil
	}
	return fmt.Errorf("unknown NotificationClient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationClientMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationClientMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationClientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationClientMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationClientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationClientMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationClientMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown NotificationClient unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationClientMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown NotificationClient edge %s", name)
}

// SettingsMutation represents an operation that mutates the Settings nodes in the graph.
type SettingsMutation struct {
	config
	op            Op
	typ           string
	id            *int
	key           *string
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Settings, error)
	predicates    []predicate.Settings
}

var _ ent.Mutation = (*SettingsMutation)(nil)

// settingsOption allows management of the mutation configuration using functional options.
type settingsOption func(*SettingsMutation)

// newSettingsMutation creates new mutation for the Settings entity.
func newSettingsMutation(c config, op Op, opts ...settingsOption) *SettingsMutation {
	m := &SettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeSettings,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSettingsID sets the ID field of the mutation.
func withSettingsID(id int) settingsOption {
	return func(m *SettingsMutation) {
		var (
			err   error
			once  sync.Once
			value *Settings
		)
		m.oldValue = func(ctx context.Context) (*Settings, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Settings.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSettings sets the old Settings of the mutation.
func withSettings(node *Settings) settingsOption {
	return func(m *SettingsMutation) {
		m.oldValue = func(context.Context) (*Settings, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SettingsMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Settings.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetKey sets the "key" field.
func (m *SettingsMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *SettingsMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *SettingsMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *SettingsMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SettingsMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Settings entity.
// If the Settings object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SettingsMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SettingsMutation) ResetValue() {
	m.value = nil
}

// Where appends a list predicates to the SettingsMutation builder.
func (m *SettingsMutation) Where(ps ...predicate.Settings) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SettingsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SettingsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Settings, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SettingsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SettingsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Settings).
func (m *SettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SettingsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.key != nil {
		fields = append(fields, settings.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, settings.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case settings.FieldKey:
		return m.Key()
	case settings.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SettingsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case settings.FieldKey:
		return m.OldKey(ctx)
	case settings.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Settings field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case settings.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case settings.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Settings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SettingsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SettingsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Settings nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SettingsMutation) ResetField(name string) error {
	switch name {
	case settings.FieldKey:
		m.ResetKey()
		return nil
	case settings.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Settings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SettingsMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SettingsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SettingsMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Settings unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SettingsMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Settings edge %s", name)
}

// StorageMutation represents an operation that mutates the Storage nodes in the graph.
type StorageMutation struct {
	config
	op             Op
	typ            string
	id             *int
	name           *string
	implementation *storage.Implementation
	tv_path        *string
	movie_path     *string
	settings       *string
	deleted        *bool
	_default       *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*Storage, error)
	predicates     []predicate.Storage
}

var _ ent.Mutation = (*StorageMutation)(nil)

// storageOption allows management of the mutation configuration using functional options.
type storageOption func(*StorageMutation)

// newStorageMutation creates new mutation for the Storage entity.
func newStorageMutation(c config, op Op, opts ...storageOption) *StorageMutation {
	m := &StorageMutation{
		config:        c,
		op:            op,
		typ:           TypeStorage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStorageID sets the ID field of the mutation.
func withStorageID(id int) storageOption {
	return func(m *StorageMutation) {
		var (
			err   error
			once  sync.Once
			value *Storage
		)
		m.oldValue = func(ctx context.Context) (*Storage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Storage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStorage sets the old Storage of the mutation.
func withStorage(node *Storage) storageOption {
	return func(m *StorageMutation) {
		m.oldValue = func(context.Context) (*Storage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StorageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StorageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StorageMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StorageMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Storage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *StorageMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StorageMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StorageMutation) ResetName() {
	m.name = nil
}

// SetImplementation sets the "implementation" field.
func (m *StorageMutation) SetImplementation(s storage.Implementation) {
	m.implementation = &s
}

// Implementation returns the value of the "implementation" field in the mutation.
func (m *StorageMutation) Implementation() (r storage.Implementation, exists bool) {
	v := m.implementation
	if v == nil {
		return
	}
	return *v, true
}

// OldImplementation returns the old "implementation" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldImplementation(ctx context.Context) (v storage.Implementation, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImplementation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImplementation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImplementation: %w", err)
	}
	return oldValue.Implementation, nil
}

// ResetImplementation resets all changes to the "implementation" field.
func (m *StorageMutation) ResetImplementation() {
	m.implementation = nil
}

// SetTvPath sets the "tv_path" field.
func (m *StorageMutation) SetTvPath(s string) {
	m.tv_path = &s
}

// TvPath returns the value of the "tv_path" field in the mutation.
func (m *StorageMutation) TvPath() (r string, exists bool) {
	v := m.tv_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTvPath returns the old "tv_path" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldTvPath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTvPath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTvPath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTvPath: %w", err)
	}
	return oldValue.TvPath, nil
}

// ClearTvPath clears the value of the "tv_path" field.
func (m *StorageMutation) ClearTvPath() {
	m.tv_path = nil
	m.clearedFields[storage.FieldTvPath] = struct{}{}
}

// TvPathCleared returns if the "tv_path" field was cleared in this mutation.
func (m *StorageMutation) TvPathCleared() bool {
	_, ok := m.clearedFields[storage.FieldTvPath]
	return ok
}

// ResetTvPath resets all changes to the "tv_path" field.
func (m *StorageMutation) ResetTvPath() {
	m.tv_path = nil
	delete(m.clearedFields, storage.FieldTvPath)
}

// SetMoviePath sets the "movie_path" field.
func (m *StorageMutation) SetMoviePath(s string) {
	m.movie_path = &s
}

// MoviePath returns the value of the "movie_path" field in the mutation.
func (m *StorageMutation) MoviePath() (r string, exists bool) {
	v := m.movie_path
	if v == nil {
		return
	}
	return *v, true
}

// OldMoviePath returns the old "movie_path" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldMoviePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMoviePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMoviePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMoviePath: %w", err)
	}
	return oldValue.MoviePath, nil
}

// ClearMoviePath clears the value of the "movie_path" field.
func (m *StorageMutation) ClearMoviePath() {
	m.movie_path = nil
	m.clearedFields[storage.FieldMoviePath] = struct{}{}
}

// MoviePathCleared returns if the "movie_path" field was cleared in this mutation.
func (m *StorageMutation) MoviePathCleared() bool {
	_, ok := m.clearedFields[storage.FieldMoviePath]
	return ok
}

// ResetMoviePath resets all changes to the "movie_path" field.
func (m *StorageMutation) ResetMoviePath() {
	m.movie_path = nil
	delete(m.clearedFields, storage.FieldMoviePath)
}

// SetSettings sets the "settings" field.
func (m *StorageMutation) SetSettings(s string) {
	m.settings = &s
}

// Settings returns the value of the "settings" field in the mutation.
func (m *StorageMutation) Settings() (r string, exists bool) {
	v := m.settings
	if v == nil {
		return
	}
	return *v, true
}

// OldSettings returns the old "settings" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldSettings(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSettings is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSettings requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSettings: %w", err)
	}
	return oldValue.Settings, nil
}

// ClearSettings clears the value of the "settings" field.
func (m *StorageMutation) ClearSettings() {
	m.settings = nil
	m.clearedFields[storage.FieldSettings] = struct{}{}
}

// SettingsCleared returns if the "settings" field was cleared in this mutation.
func (m *StorageMutation) SettingsCleared() bool {
	_, ok := m.clearedFields[storage.FieldSettings]
	return ok
}

// ResetSettings resets all changes to the "settings" field.
func (m *StorageMutation) ResetSettings() {
	m.settings = nil
	delete(m.clearedFields, storage.FieldSettings)
}

// SetDeleted sets the "deleted" field.
func (m *StorageMutation) SetDeleted(b bool) {
	m.deleted = &b
}

// Deleted returns the value of the "deleted" field in the mutation.
func (m *StorageMutation) Deleted() (r bool, exists bool) {
	v := m.deleted
	if v == nil {
		return
	}
	return *v, true
}

// OldDeleted returns the old "deleted" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldDeleted(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeleted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeleted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeleted: %w", err)
	}
	return oldValue.Deleted, nil
}

// ResetDeleted resets all changes to the "deleted" field.
func (m *StorageMutation) ResetDeleted() {
	m.deleted = nil
}

// SetDefault sets the "default" field.
func (m *StorageMutation) SetDefault(b bool) {
	m._default = &b
}

// Default returns the value of the "default" field in the mutation.
func (m *StorageMutation) Default() (r bool, exists bool) {
	v := m._default
	if v == nil {
		return
	}
	return *v, true
}

// OldDefault returns the old "default" field's value of the Storage entity.
// If the Storage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StorageMutation) OldDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefault: %w", err)
	}
	return oldValue.Default, nil
}

// ResetDefault resets all changes to the "default" field.
func (m *StorageMutation) ResetDefault() {
	m._default = nil
}

// Where appends a list predicates to the StorageMutation builder.
func (m *StorageMutation) Where(ps ...predicate.Storage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StorageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StorageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Storage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StorageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StorageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Storage).
func (m *StorageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StorageMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.name != nil {
		fields = append(fields, storage.FieldName)
	}
	if m.implementation != nil {
		fields = append(fields, storage.FieldImplementation)
	}
	if m.tv_path != nil {
		fields = append(fields, storage.FieldTvPath)
	}
	if m.movie_path != nil {
		fields = append(fields, storage.FieldMoviePath)
	}
	if m.settings != nil {
		fields = append(fields, storage.FieldSettings)
	}
	if m.deleted != nil {
		fields = append(fields, storage.FieldDeleted)
	}
	if m._default != nil {
		fields = append(fields, storage.FieldDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StorageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storage.FieldName:
		return m.Name()
	case storage.FieldImplementation:
		return m.Implementation()
	case storage.FieldTvPath:
		return m.TvPath()
	case storage.FieldMoviePath:
		return m.MoviePath()
	case storage.FieldSettings:
		return m.Settings()
	case storage.FieldDeleted:
		return m.Deleted()
	case storage.FieldDefault:
		return m.Default()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StorageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storage.FieldName:
		return m.OldName(ctx)
	case storage.FieldImplementation:
		return m.OldImplementation(ctx)
	case storage.FieldTvPath:
		return m.OldTvPath(ctx)
	case storage.FieldMoviePath:
		return m.OldMoviePath(ctx)
	case storage.FieldSettings:
		return m.OldSettings(ctx)
	case storage.FieldDeleted:
		return m.OldDeleted(ctx)
	case storage.FieldDefault:
		return m.OldDefault(ctx)
	}
	return nil, fmt.Errorf("unknown Storage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storage.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case storage.FieldImplementation:
		v, ok := value.(storage.Implementation)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImplementation(v)
		return nil
	case storage.FieldTvPath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTvPath(v)
		return nil
	case storage.FieldMoviePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMoviePath(v)
		return nil
	case storage.FieldSettings:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSettings(v)
		return nil
	case storage.FieldDeleted:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeleted(v)
		return nil
	case storage.FieldDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefault(v)
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StorageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StorageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StorageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Storage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StorageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storage.FieldTvPath) {
		fields = append(fields, storage.FieldTvPath)
	}
	if m.FieldCleared(storage.FieldMoviePath) {
		fields = append(fields, storage.FieldMoviePath)
	}
	if m.FieldCleared(storage.FieldSettings) {
		fields = append(fields, storage.FieldSettings)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StorageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StorageMutation) ClearField(name string) error {
	switch name {
	case storage.FieldTvPath:
		m.ClearTvPath()
		return nil
	case storage.FieldMoviePath:
		m.ClearMoviePath()
		return nil
	case storage.FieldSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown Storage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StorageMutation) ResetField(name string) error {
	switch name {
	case storage.FieldName:
		m.ResetName()
		return nil
	case storage.FieldImplementation:
		m.ResetImplementation()
		return nil
	case storage.FieldTvPath:
		m.ResetTvPath()
		return nil
	case storage.FieldMoviePath:
		m.ResetMoviePath()
		return nil
	case storage.FieldSettings:
		m.ResetSettings()
		return nil
	case storage.FieldDeleted:
		m.ResetDeleted()
		return nil
	case storage.FieldDefault:
		m.ResetDefault()
		return nil
	}
	return fmt.Errorf("unknown Storage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StorageMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StorageMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StorageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StorageMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StorageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StorageMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StorageMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Storage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StorageMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Storage edge %s", name)
}
